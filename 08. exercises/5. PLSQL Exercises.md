# PL/SQL Exercises, Supporting Data, and Solutions

## Table of Contents
1. [Getting Started with PL/SQL](#01-Getting-Started-with-PLSQL)
2. [Flow Control (Conditional Statements)](#02-Flow-Control-Conditional-Statements)
3. [Flow Control (Iterative Statements)](#03-Flow-Control-Iterative-Statements)
4. [SELECT INTO](#04-SELECT-INTO)
5. [Exceptions](#05-Exceptions)
6. [Cursors](#06-Cursors)
7. [Records](#07-Records)
8. [Procedures](#08-procedures)
9. [Functions](#09-functions)
10. [Packages](#10-packages)
11. [Triggers](#11-triggers)
12. [Collections](#12-collections)
13. [Bulk Collect](#13-bulk-collect)
14. [Dynamic SQL](#14-dynamic-sql)
15. [Table Functions](#15-table-functions)
16. [Objects](#16-objects)
17. [Database Link](#17-database-link)

---

### 01. Getting Started with PL/SQL

#### Exercises
1. Write a basic PL/SQL block to display "Hello World" using `DBMS_OUTPUT.PUT_LINE`.
2. Create a PL/SQL block that declares and uses a local variable.
3. Write a PL/SQL block to demonstrate the use of `BEGIN ... END` and `;` to terminate statements.
4. Develop a PL/SQL block that performs arithmetic operations and displays the result.
5. Write a PL/SQL block to declare and use a constant.
6. Create a PL/SQL block to demonstrate the use of `NULL` values.
7. Develop a PL/SQL block to display the current date and time using `SYSDATE`.
8. Write a PL/SQL block to concatenate two strings and display the result.
9. Create a PL/SQL block to demonstrate variable data type conversions.
10. Write a PL/SQL block to use `DBMS_OUTPUT.PUT_LINE` to display multiple lines of text.

#### Supporting Data
N/A

#### Solutions

```plsql
-- 1. Hello World
BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello World');
END;

-- 2. Local Variable Usage
DECLARE
    v_message VARCHAR2(50);
BEGIN
    v_message := 'Hello PL/SQL';
    DBMS_OUTPUT.PUT_LINE(v_message);
END;

-- 3. Basic PL/SQL Block
BEGIN
    DBMS_OUTPUT.PUT_LINE('This is a basic PL/SQL block');
END;

-- 4. Arithmetic Operations
DECLARE
    v_a NUMBER := 10;
    v_b NUMBER := 20;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Sum: ' || (v_a + v_b));
    DBMS_OUTPUT.PUT_LINE('Difference: ' || (v_a - v_b));
    DBMS_OUTPUT.PUT_LINE('Product: ' || (v_a * v_b));
    DBMS_OUTPUT.PUT_LINE('Quotient: ' || (v_a / v_b));
END;

-- 5. Using Constants
DECLARE
    c_pi CONSTANT NUMBER := 3.14;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Value of Pi: ' || c_pi);
END;

-- 6. NULL Values
DECLARE
    v_value NUMBER;
BEGIN
    v_value := NULL;
    DBMS_OUTPUT.PUT_LINE('Value: ' || NVL(v_value, 'NULL'));
END;

-- 7. Display Current Date and Time
BEGIN
    DBMS_OUTPUT.PUT_LINE('Current Date and Time: ' || SYSDATE);
END;

-- 8. String Concatenation
DECLARE
    v_str1 VARCHAR2(50) := 'Hello';
    v_str2 VARCHAR2(50) := 'World';
BEGIN
    DBMS_OUTPUT.PUT_LINE(v_str1 || ' ' || v_str2);
END;

-- 9. Data Type Conversion
DECLARE
    v_num NUMBER := 123.45;
    v_str VARCHAR2(20);
BEGIN
    v_str := TO_CHAR(v_num);
    DBMS_OUTPUT.PUT_LINE('Number as String: ' || v_str);
END;

-- 10. Multiple Lines
BEGIN
    DBMS_OUTPUT.PUT_LINE('Line 1');
    DBMS_OUTPUT.PUT_LINE('Line 2');
    DBMS_OUTPUT.PUT_LINE('Line 3');
END;
```

### 02. Flow Control (Conditional Statements)

#### Exercises
1. Write a PL/SQL block that uses an `IF` statement to check if a number is positive or negative.
2. Create a PL/SQL block that uses an `IF-ELSE` statement to categorize a number as small, medium, or large.
3. Write a PL/SQL block that uses `CASE` expression to assign a grade based on a numeric score.
4. Develop a PL/SQL block that uses a nested `IF` statement to check multiple conditions.
5. Create a PL/SQL block that uses a `CASE` expression to return a day of the week based on a numeric value.
6. Write a PL/SQL block that demonstrates the use of `DECODE` function for conditional logic.
7. Create a PL/SQL block that checks for a NULL value using `IF` statement.
8. Write a PL/SQL block that uses `IF` statement to compare two strings.
9. Develop a PL/SQL block to demonstrate `IF-THEN-ELSE` with multiple conditions.
10. Write a PL/SQL block that uses `CASE` expression to return a message based on a status code.

#### Supporting Data
N/A

#### Solutions

```plsql
-- 1. Positive or Negative Check
DECLARE
    v_number NUMBER := -5;
BEGIN
    IF v_number >= 0 THEN
        DBMS_OUTPUT.PUT_LINE('The number is positive or zero');
    ELSE
        DBMS_OUTPUT.PUT_LINE('The number is negative');
    END IF;
END;

-- 2. Number Categorization
DECLARE
    v_number NUMBER := 15;
BEGIN
    IF v_number < 10 THEN
        DBMS_OUTPUT.PUT_LINE('Small');
    ELSIF v_number BETWEEN 10 AND 20 THEN
        DBMS_OUTPUT.PUT_LINE('Medium');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Large');
    END IF;
END;

-- 3. Grade Assignment
DECLARE
    v_score NUMBER := 85;
BEGIN
    DBMS_OUTPUT.PUT_LINE(
        CASE
            WHEN v_score >= 90 THEN 'A'
            WHEN v_score >= 80 THEN 'B'
            WHEN v_score >= 70 THEN 'C'
            ELSE 'F'
        END
    );
END;

-- 4. Nested IF Statement
DECLARE
    v_number NUMBER := 15;
BEGIN
    IF v_number > 0 THEN
        IF v_number < 10 THEN
            DBMS_OUTPUT.PUT_LINE('Single digit positive number');
        ELSE
            DBMS_OUTPUT.PUT_LINE('Positive number with more than one digit');
        END IF;
    ELSE
        DBMS_OUTPUT.PUT_LINE('Non-positive number');
    END IF;
END;

-- 5. Day of the Week
DECLARE
    v_day NUMBER := 3;
BEGIN
    DBMS_OUTPUT.PUT_LINE(
        CASE v_day
            WHEN 1 THEN 'Sunday'
            WHEN 2 THEN 'Monday'
            WHEN 3 THEN 'Tuesday'
            WHEN 4 THEN 'Wednesday'
            WHEN 5 THEN 'Thursday'
            WHEN 6 THEN 'Friday'
            WHEN 7 THEN 'Saturday'
            ELSE 'Invalid day'
        END
    );
END;

-- 6. DECODE Function
DECLARE
    v_status NUMBER := 2;
BEGIN
    DBMS_OUTPUT.PUT_LINE(
        DECODE(v_status, 
               1, 'Active', 
               2, 'Inactive', 
               'Unknown')
    );
END;

-- 7. NULL Value Check
DECLARE
    v_value NUMBER;
BEGIN
    IF v_value IS NULL THEN
        DBMS_OUTPUT.PUT_LINE('Value is NULL');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Value is not NULL');
    END IF;
END;

-- 8. String Comparison
DECLARE
    v_str1 VARCHAR2(20) := 'Hello';
    v_str2 VARCHAR2(20) := 'World';
BEGIN
    IF v_str1 = v_str2 THEN
        DBMS_OUTPUT.PUT_LINE('Strings are equal');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Strings are not equal');
    END IF;
END;

-- 9. Multiple Conditions
DECLARE
    v_number NUMBER := 25;
BEGIN
    IF v_number < 10 THEN
        DBMS_OUTPUT.PUT_LINE('Less than 10');
    ELSIF v_number BETWEEN 10 AND 20 THEN
        DBMS_OUTPUT.PUT_LINE('Between 10 and 20');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Greater than 20');
    END IF;
END;

-- 10. Status Code Message
DECLARE
    v_status_code NUMBER := 404;
BEGIN
    DBMS_OUTPUT.PUT_LINE(
        CASE v_status_code
            WHEN 200 THEN 'OK'
            WHEN 404 THEN 'Not Found'
            WHEN 500 THEN 'Internal Server Error'
            ELSE 'Unknown Status'
        END
    );
END;
```

### 03. Flow Control (Iterative Statements)

#### Exercises
1. Write a PL/SQL block to use a `FOR` loop to display numbers from 1 to 10.
2. Create a PL/SQL block to use a `WHILE` loop to display numbers from 1 to 10.
3. Write a PL/SQL block to use a `LOOP` statement with `EXIT` to display numbers from 1 to 10.
4. Develop a PL/SQL block to use a `FOR` loop with a range of values.
5. Create a PL/SQL block to use `EXIT WHEN` inside a `LOOP` to terminate based on a condition.
6. Write a PL/SQL block to use a `FOR` loop to iterate over a list of values.
7. Develop a PL/SQL block to use nested loops to display a multiplication table.
8. Create a PL/SQL block to use `CONTINUE` inside a `LOOP` to skip an iteration.
9. Write a PL/SQL block to use `LOOP` with a cursor to process rows.
10. Develop a PL/SQL block to demonstrate the use of `EXIT` to break out of nested loops.

#### Supporting Data
N/A

#### Solutions

```plsql


-- 1. FOR Loop
BEGIN
    FOR i IN 1..10 LOOP
        DBMS_OUTPUT.PUT_LINE(i);
    END LOOP;
END;

-- 2. WHILE Loop
DECLARE
    v_counter NUMBER := 1;
BEGIN
    WHILE v_counter <= 10 LOOP
        DBMS_OUTPUT.PUT_LINE(v_counter);
        v_counter := v_counter + 1;
    END LOOP;
END;

-- 3. Basic Loop with EXIT
DECLARE
    v_counter NUMBER := 1;
BEGIN
    LOOP
        EXIT WHEN v_counter > 10;
        DBMS_OUTPUT.PUT_LINE(v_counter);
        v_counter := v_counter + 1;
    END LOOP;
END;

-- 4. FOR Loop with Range
BEGIN
    FOR i IN 5..15 LOOP
        DBMS_OUTPUT.PUT_LINE(i);
    END LOOP;
END;

-- 5. EXIT WHEN in LOOP
DECLARE
    v_counter NUMBER := 1;
BEGIN
    LOOP
        DBMS_OUTPUT.PUT_LINE(v_counter);
        v_counter := v_counter + 1;
        EXIT WHEN v_counter > 10;
    END LOOP;
END;

-- 6. FOR Loop over List
BEGIN
    FOR v_item IN (SELECT department_id FROM departments) LOOP
        DBMS_OUTPUT.PUT_LINE('Department ID: ' || v_item.department_id);
    END LOOP;
END;

-- 7. Nested Loops for Multiplication Table
DECLARE
    v_i NUMBER;
    v_j NUMBER;
BEGIN
    FOR v_i IN 1..10 LOOP
        FOR v_j IN 1..10 LOOP
            DBMS_OUTPUT.PUT_LINE(v_i || ' * ' || v_j || ' = ' || (v_i * v_j));
        END LOOP;
    END LOOP;
END;

-- 8. CONTINUE in LOOP
DECLARE
    v_counter NUMBER := 1;
BEGIN
    LOOP
        v_counter := v_counter + 1;
        IF v_counter = 5 THEN
            CONTINUE;
        END IF;
        DBMS_OUTPUT.PUT_LINE(v_counter);
        EXIT WHEN v_counter >= 10;
    END LOOP;
END;

-- 9. Loop with Cursor
DECLARE
    CURSOR emp_cursor IS
        SELECT emp_name FROM employees;
    v_employee employees%ROWTYPE;
BEGIN
    OPEN emp_cursor;
    LOOP
        FETCH emp_cursor INTO v_employee;
        EXIT WHEN emp_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_employee.emp_name);
    END LOOP;
    CLOSE emp_cursor;
END;

-- 10. EXIT in Nested Loops
DECLARE
    v_i NUMBER := 1;
    v_j NUMBER := 1;
BEGIN
    FOR v_i IN 1..3 LOOP
        FOR v_j IN 1..3 LOOP
            IF v_j = 2 THEN
                EXIT;
            END IF;
            DBMS_OUTPUT.PUT_LINE('i: ' || v_i || ', j: ' || v_j);
        END LOOP;
    END LOOP;
END;
```

### 04. SELECT INTO

#### Exercises
1. Write a PL/SQL block to select a single row into a variable.
2. Create a PL/SQL block to select multiple columns from a single row into variables.
3. Write a PL/SQL block to handle the scenario where no rows are returned by the `SELECT INTO`.
4. Develop a PL/SQL block to select a value from a table and use it in a calculation.
5. Create a PL/SQL block to select a value based on a condition.
6. Write a PL/SQL block to select data into a record type.
7. Develop a PL/SQL block to handle the exception when more than one row is selected.
8. Create a PL/SQL block to select data into variables and display the results.
9. Write a PL/SQL block to select a row into a variable and check for NULL values.
10. Develop a PL/SQL block to select data into multiple variables and use it in further processing.

#### Supporting Data
Assuming the following `employees` table:
```sql
CREATE TABLE employees (
    emp_id NUMBER PRIMARY KEY,
    emp_name VARCHAR2(50),
    emp_salary NUMBER
);
```

#### Solutions

```plsql
-- 1. Single Row into Variable
DECLARE
    v_name employees.emp_name%TYPE;
BEGIN
    SELECT emp_name
    INTO v_name
    FROM employees
    WHERE emp_id = 1;
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name);
END;

-- 2. Multiple Columns into Variables
DECLARE
    v_name employees.emp_name%TYPE;
    v_salary employees.emp_salary%TYPE;
BEGIN
    SELECT emp_name, emp_salary
    INTO v_name, v_salary
    FROM employees
    WHERE emp_id = 1;
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name || ', Salary: ' || v_salary);
END;

-- 3. No Rows Returned
DECLARE
    v_name employees.emp_name%TYPE;
BEGIN
    BEGIN
        SELECT emp_name
        INTO v_name
        FROM employees
        WHERE emp_id = 999; -- Assuming 999 does not exist
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('No data found for the given ID');
    END;
END;

-- 4. Value in Calculation
DECLARE
    v_salary employees.emp_salary%TYPE;
    v_bonus NUMBER;
BEGIN
    SELECT emp_salary
    INTO v_salary
    FROM employees
    WHERE emp_id = 1;
    v_bonus := v_salary * 0.10;
    DBMS_OUTPUT.PUT_LINE('Bonus: ' || v_bonus);
END;

-- 5. Select Based on Condition
DECLARE
    v_name employees.emp_name%TYPE;
BEGIN
    SELECT emp_name
    INTO v_name
    FROM employees
    WHERE emp_salary > 50000; -- Assuming at least one employee has salary > 50000
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name);
END;

-- 6. Data into Record Type
DECLARE
    TYPE emp_record IS RECORD (
        emp_name employees.emp_name%TYPE,
        emp_salary employees.emp_salary%TYPE
    );
    v_employee emp_record;
BEGIN
    SELECT emp_name, emp_salary
    INTO v_employee
    FROM employees
    WHERE emp_id = 1;
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_employee.emp_name || ', Salary: ' || v_employee.emp_salary);
END;

-- 7. Exception for Multiple Rows
DECLARE
    v_name employees.emp_name%TYPE;
BEGIN
    BEGIN
        SELECT emp_name
        INTO v_name
        FROM employees;
    EXCEPTION
        WHEN TOO_MANY_ROWS THEN
            DBMS_OUTPUT.PUT_LINE('Too many rows returned');
    END;
END;

-- 8. Data into Variables and Display
DECLARE
    v_name employees.emp_name%TYPE;
    v_salary employees.emp_salary%TYPE;
BEGIN
    SELECT emp_name, emp_salary
    INTO v_name, v_salary
    FROM employees
    WHERE emp_id = 1;
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name || ', Salary: ' || v_salary);
END;

-- 9. Handling NULL Values
DECLARE
    v_name employees.emp_name%TYPE;
BEGIN
    SELECT emp_name
    INTO v_name
    FROM employees
    WHERE emp_id = 2; -- Assuming emp_id 2 has NULL name
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || NVL(v_name, 'No Name'));
END;

-- 10. Data into Multiple Variables
DECLARE
    v_name employees.emp_name%TYPE;
    v_salary employees.emp_salary%TYPE;
    v_message VARCHAR2(100);
BEGIN
    SELECT emp_name, emp_salary
    INTO v_name, v_salary
    FROM employees
    WHERE emp_id = 1;
    v_message := 'Name: ' || v_name || ', Salary: ' || v_salary;
    DBMS_OUTPUT.PUT_LINE(v_message);
END;
```

### 05. Exceptions

#### Exercises
1. Write a PL/SQL block to handle the `NO_DATA_FOUND` exception.
2. Create a PL/SQL block to handle the `TOO_MANY_ROWS` exception.
3. Write a PL/SQL block to handle a custom exception.
4. Develop a PL/SQL block to raise a predefined exception.
5. Create a PL/SQL block that uses `SQLCODE` and `SQLERRM` to display error information.
6. Write a PL/SQL block to demonstrate handling multiple exceptions.
7. Develop a PL/SQL block to handle exceptions within a procedure.
8. Create a PL/SQL block to handle the `ZERO_DIVIDE` exception.
9. Write a PL/SQL block to log errors to a custom error table.
10. Develop a PL/SQL block to re-raise exceptions after handling.

#### Supporting Data
Assuming the following `employees` table:
```sql
CREATE TABLE employees (
    emp_id NUMBER PRIMARY KEY,
    emp_name VARCHAR2(50),
    emp_salary NUMBER
);
```

And a custom error table:
```sql
CREATE TABLE error_log (
    error_time TIMESTAMP,
    error_code NUMBER,
    error_message VARCHAR2(4000)
);
```

#### Solutions

```plsql
-- 1. NO_DATA_FOUND Exception
DECLARE
    v_name employees.emp_name%TYPE;
BEGIN
    BEGIN
        SELECT emp_name
        INTO v_name
        FROM employees
        WHERE emp_id = 999; -- Assuming 999 does not exist
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('No data found');
    END;
END;



-- 2. TOO_MANY_ROWS Exception
DECLARE
    v_name employees.emp_name%TYPE;
BEGIN
    BEGIN
        SELECT emp_name
        INTO v_name
        FROM employees;
    EXCEPTION
        WHEN TOO_MANY_ROWS THEN
            DBMS_OUTPUT.PUT_LINE('Too many rows returned');
    END;
END;

-- 3. Custom Exception
DECLARE
    e_custom EXCEPTION;
    v_value NUMBER := 10;
BEGIN
    IF v_value > 5 THEN
        RAISE e_custom;
    END IF;
EXCEPTION
    WHEN e_custom THEN
        DBMS_OUTPUT.PUT_LINE('Custom exception handled');
END;

-- 4. Raise Predefined Exception
BEGIN
    RAISE_APPLICATION_ERROR(-20001, 'Custom error message');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;

-- 5. SQLCODE and SQLERRM
DECLARE
    v_name employees.emp_name%TYPE;
BEGIN
    BEGIN
        SELECT emp_name
        INTO v_name
        FROM employees
        WHERE emp_id = 999; -- Assuming 999 does not exist
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('Error Code: ' || SQLCODE || ', Error Message: ' || SQLERRM);
    END;
END;

-- 6. Multiple Exceptions
BEGIN
    BEGIN
        SELECT emp_name
        INTO v_name
        FROM employees
        WHERE emp_id = 999;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('No data found');
        WHEN TOO_MANY_ROWS THEN
            DBMS_OUTPUT.PUT_LINE('Too many rows');
    END;
END;

-- 7. Exceptions in Procedure
CREATE OR REPLACE PROCEDURE proc_example IS
BEGIN
    SELECT emp_name INTO v_name FROM employees WHERE emp_id = 999;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No data found in procedure');
END;

BEGIN
    proc_example;
END;

-- 8. ZERO_DIVIDE Exception
DECLARE
    v_result NUMBER;
BEGIN
    BEGIN
        v_result := 1 / 0;
    EXCEPTION
        WHEN ZERO_DIVIDE THEN
            DBMS_OUTPUT.PUT_LINE('Division by zero');
    END;
END;

-- 9. Log Errors to Table
DECLARE
    v_name employees.emp_name%TYPE;
BEGIN
    BEGIN
        SELECT emp_name INTO v_name FROM employees WHERE emp_id = 999;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            INSERT INTO error_log (error_time, error_code, error_message)
            VALUES (SYSTIMESTAMP, SQLCODE, SQLERRM);
    END;
END;

-- 10. Re-raise Exception
BEGIN
    BEGIN
        SELECT emp_name INTO v_name FROM employees WHERE emp_id = 999;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('No data found');
            RAISE;
    END;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Exception re-raised: ' || SQLERRM);
END;
```

### 06. Cursors

#### Exercises
1. Write a PL/SQL block to declare and use a cursor to fetch employee names.
2. Create a PL/SQL block to use a cursor for fetching multiple rows from the `employees` table.
3. Write a PL/SQL block to demonstrate using a cursor with parameters.
4. Develop a PL/SQL block to use a cursor to update records in the `employees` table.
5. Create a PL/SQL block to use a cursor for inserting records into a different table.
6. Write a PL/SQL block to fetch data using a cursor and handle exceptions.
7. Develop a PL/SQL block to demonstrate using a cursor with a loop.
8. Create a PL/SQL block to use a cursor to delete records from the `employees` table.
9. Write a PL/SQL block to use a cursor with a `FOR` loop to process rows.
10. Develop a PL/SQL block to use a cursor for complex joins and display results.

#### Supporting Data
Assuming the following `employees` table:
```sql
CREATE TABLE employees (
    emp_id NUMBER PRIMARY KEY,
    emp_name VARCHAR2(50),
    emp_salary NUMBER
);
```

#### Solutions

```plsql
-- 1. Basic Cursor
DECLARE
    CURSOR emp_cursor IS
        SELECT emp_name FROM employees;
    v_name employees.emp_name%TYPE;
BEGIN
    OPEN emp_cursor;
    LOOP
        FETCH emp_cursor INTO v_name;
        EXIT WHEN emp_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name);
    END LOOP;
    CLOSE emp_cursor;
END;

-- 2. Cursor for Multiple Rows
DECLARE
    CURSOR emp_cursor IS
        SELECT emp_name, emp_salary FROM employees;
    v_name employees.emp_name%TYPE;
    v_salary employees.emp_salary%TYPE;
BEGIN
    OPEN emp_cursor;
    LOOP
        FETCH emp_cursor INTO v_name, v_salary;
        EXIT WHEN emp_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Name: ' || v_name || ', Salary: ' || v_salary);
    END LOOP;
    CLOSE emp_cursor;
END;

-- 3. Cursor with Parameters
DECLARE
    CURSOR emp_cursor(p_id NUMBER) IS
        SELECT emp_name FROM employees WHERE emp_id = p_id;
    v_name employees.emp_name%TYPE;
BEGIN
    OPEN emp_cursor(1);
    FETCH emp_cursor INTO v_name;
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name);
    CLOSE emp_cursor;
END;

-- 4. Cursor to Update Records
DECLARE
    CURSOR emp_cursor IS
        SELECT emp_id FROM employees WHERE emp_salary < 30000;
    v_emp_id employees.emp_id%TYPE;
BEGIN
    OPEN emp_cursor;
    LOOP
        FETCH emp_cursor INTO v_emp_id;
        EXIT WHEN emp_cursor%NOTFOUND;
        UPDATE employees
        SET emp_salary = emp_salary + 5000
        WHERE emp_id = v_emp_id;
    END LOOP;
    CLOSE emp_cursor;
    COMMIT;
END;

-- 5. Cursor for Inserting Records
DECLARE
    CURSOR emp_cursor IS
        SELECT emp_name, emp_salary FROM employees WHERE emp_salary > 50000;
BEGIN
    FOR rec IN emp_cursor LOOP
        INSERT INTO high_salary_employees (emp_name, emp_salary)
        VALUES (rec.emp_name, rec.emp_salary);
    END LOOP;
    COMMIT;
END;

-- 6. Cursor with Exception Handling
DECLARE
    CURSOR emp_cursor IS
        SELECT emp_name FROM employees;
    v_name employees.emp_name%TYPE;
BEGIN
    BEGIN
        OPEN emp_cursor;
        LOOP
            FETCH emp_cursor INTO v_name;
            EXIT WHEN emp_cursor%NOTFOUND;
            DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name);
        END LOOP;
        CLOSE emp_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    END;
END;

-- 7. Cursor with Loop
DECLARE
    CURSOR emp_cursor IS
        SELECT emp_name FROM employees;
BEGIN
    FOR v_employee IN emp_cursor LOOP
        DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_employee.emp_name);
    END LOOP;
END;

-- 8. Cursor to Delete Records
DECLARE
    CURSOR emp_cursor IS
        SELECT emp_id FROM employees WHERE emp_salary < 20000;
BEGIN
    OPEN emp_cursor;
    LOOP
        FETCH emp_cursor INTO v_emp_id;
        EXIT WHEN emp_cursor%NOTFOUND;
        DELETE FROM employees WHERE emp_id = v_emp_id;
    END LOOP;
    CLOSE emp_cursor;
    COMMIT;
END;

-- 9. Cursor with FOR Loop
DECLARE
    CURSOR emp_cursor IS
        SELECT emp_name FROM employees;
BEGIN
    FOR rec IN emp_cursor LOOP
        DBMS_OUTPUT.PUT_LINE('Employee Name: ' || rec.emp_name);
    END LOOP;
END;

-- 10. Cursor with Joins
DECLARE
    CURSOR emp_cursor IS
        SELECT e.emp_name, d.department_name
        FROM employees e
        JOIN departments d ON e.department_id = d.department_id;
BEGIN
    OPEN emp_cursor;
    LOOP
        FETCH emp_cursor INTO v_name, v_department_name;
        EXIT WHEN emp_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee: ' || v_name || ', Department: ' || v_department_name);
    END LOOP;
    CLOSE emp_cursor;
END;
```

### 07. Records

#### Exercises
1. Write a PL/SQL block to declare and use a record type.
2. Create a PL/SQL block to use a record type to store multiple columns from a table.
3. Write a PL/SQL block to demonstrate using a record type with a cursor.
4. Develop a PL/SQL block to use a record type with a collection.
5. Create a PL/SQL block to update table records using a record type.
6. Write a PL/SQL block to display record field values.
7. Develop a PL/SQL block to handle exceptions with record types.
8. Create a PL/SQL block to use a record type in a procedure.
9. Write a PL/SQL block to insert data into a table using a record type.
10. Develop a PL/SQL block to use a record type with dynamic SQL.

#### Supporting Data
Assuming the following `employees` table:
```sql
CREATE TABLE employees (
    emp_id NUMBER PRIMARY KEY,
    emp_name VARCHAR2(50),
   

 emp_salary NUMBER
);
```

#### Solutions

```plsql
-- 1. Basic Record Type
DECLARE
    TYPE emp_record IS RECORD (
        emp_name employees.emp_name%TYPE,
        emp_salary employees.emp_salary%TYPE
    );
    v_employee emp_record;
BEGIN
    v_employee.emp_name := 'John Doe';
    v_employee.emp_salary := 50000;
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_employee.emp_name || ', Salary: ' || v_employee.emp_salary);
END;

-- 2. Record Type with Table Data
DECLARE
    TYPE emp_record IS RECORD (
        emp_name employees.emp_name%TYPE,
        emp_salary employees.emp_salary%TYPE
    );
    v_employee emp_record;
BEGIN
    SELECT emp_name, emp_salary
    INTO v_employee
    FROM employees
    WHERE emp_id = 1;
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_employee.emp_name || ', Salary: ' || v_employee.emp_salary);
END;

-- 3. Record Type with Cursor
DECLARE
    TYPE emp_record IS RECORD (
        emp_name employees.emp_name%TYPE,
        emp_salary employees.emp_salary%TYPE
    );
    CURSOR emp_cursor IS
        SELECT emp_name, emp_salary FROM employees;
    v_employee emp_record;
BEGIN
    OPEN emp_cursor;
    LOOP
        FETCH emp_cursor INTO v_employee;
        EXIT WHEN emp_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Name: ' || v_employee.emp_name || ', Salary: ' || v_employee.emp_salary);
    END LOOP;
    CLOSE emp_cursor;
END;

-- 4. Record Type with Collection
DECLARE
    TYPE emp_record IS RECORD (
        emp_name employees.emp_name%TYPE,
        emp_salary employees.emp_salary%TYPE
    );
    TYPE emp_table IS TABLE OF emp_record INDEX BY PLS_INTEGER;
    v_employees emp_table;
BEGIN
    v_employees(1).emp_name := 'John';
    v_employees(1).emp_salary := 40000;
    v_employees(2).emp_name := 'Jane';
    v_employees(2).emp_salary := 60000;
    
    FOR i IN 1..2 LOOP
        DBMS_OUTPUT.PUT_LINE('Name: ' || v_employees(i).emp_name || ', Salary: ' || v_employees(i).emp_salary);
    END LOOP;
END;

-- 5. Update Table Records
DECLARE
    TYPE emp_record IS RECORD (
        emp_id employees.emp_id%TYPE,
        emp_salary employees.emp_salary%TYPE
    );
    v_employee emp_record;
BEGIN
    SELECT emp_id, emp_salary
    INTO v_employee
    FROM employees
    WHERE emp_id = 1;
    
    v_employee.emp_salary := v_employee.emp_salary + 5000;
    
    UPDATE employees
    SET emp_salary = v_employee.emp_salary
    WHERE emp_id = v_employee.emp_id;
    
    COMMIT;
END;

-- 6. Display Record Field Values
DECLARE
    TYPE emp_record IS RECORD (
        emp_name employees.emp_name%TYPE,
        emp_salary employees.emp_salary%TYPE
    );
    v_employee emp_record;
BEGIN
    v_employee.emp_name := 'Alice';
    v_employee.emp_salary := 70000;
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_employee.emp_name || ', Salary: ' || v_employee.emp_salary);
END;

-- 7. Exceptions with Record Types
DECLARE
    TYPE emp_record IS RECORD (
        emp_name employees.emp_name%TYPE,
        emp_salary employees.emp_salary%TYPE
    );
    v_employee emp_record;
BEGIN
    BEGIN
        SELECT emp_name, emp_salary
        INTO v_employee
        FROM employees
        WHERE emp_id = 999; -- Assuming 999 does not exist
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('No data found for the given ID');
    END;
END;

-- 8. Record Type in Procedure
CREATE OR REPLACE PROCEDURE proc_example IS
    TYPE emp_record IS RECORD (
        emp_name employees.emp_name%TYPE,
        emp_salary employees.emp_salary%TYPE
    );
    v_employee emp_record;
BEGIN
    SELECT emp_name, emp_salary
    INTO v_employee
    FROM employees
    WHERE emp_id = 1;
    
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_employee.emp_name || ', Salary: ' || v_employee.emp_salary);
END;

BEGIN
    proc_example;
END;

-- 9. Insert Data Using Record Type
DECLARE
    TYPE emp_record IS RECORD (
        emp_name employees.emp_name%TYPE,
        emp_salary employees.emp_salary%TYPE
    );
    v_employee emp_record;
BEGIN
    v_employee.emp_name := 'Mike';
    v_employee.emp_salary := 55000;
    
    INSERT INTO employees (emp_name, emp_salary)
    VALUES (v_employee.emp_name, v_employee.emp_salary);
    
    COMMIT;
END;

-- 10. Record Type with Dynamic SQL
DECLARE
    TYPE emp_record IS RECORD (
        emp_name employees.emp_name%TYPE,
        emp_salary employees.emp_salary%TYPE
    );
    v_employee emp_record;
    v_sql VARCHAR2(100);
BEGIN
    v_employee.emp_name := 'Sarah';
    v_employee.emp_salary := 65000;
    
    v_sql := 'INSERT INTO employees (emp_name, emp_salary) VALUES (:1, :2)';
    EXECUTE IMMEDIATE v_sql USING v_employee.emp_name, v_employee.emp_salary;
    
    COMMIT;
END;
```


### 08. Procedures

#### Exercise 1
Create a procedure to insert a new record into the `employees` table.

**Supporting Data:**
```sql
CREATE TABLE employees (
    emp_id NUMBER PRIMARY KEY,
    emp_name VARCHAR2(100),
    emp_salary NUMBER
);
```

**Solution:**
```plsql
CREATE OR REPLACE PROCEDURE insert_employee(
    p_emp_id IN NUMBER,
    p_emp_name IN VARCHAR2,
    p_emp_salary IN NUMBER
) IS
BEGIN
    INSERT INTO employees (emp_id, emp_name, emp_salary)
    VALUES (p_emp_id, p_emp_name, p_emp_salary);
END;
```

#### Exercise 2
Create a procedure to update an employee's salary based on their ID.

**Solution:**
```plsql
CREATE OR REPLACE PROCEDURE update_salary(
    p_emp_id IN NUMBER,
    p_new_salary IN NUMBER
) IS
BEGIN
    UPDATE employees
    SET emp_salary = p_new_salary
    WHERE emp_id = p_emp_id;
END;
```

#### Exercise 3
Create a procedure to delete an employee by ID.

**Solution:**
```plsql
CREATE OR REPLACE PROCEDURE delete_employee(
    p_emp_id IN NUMBER
) IS
BEGIN
    DELETE FROM employees
    WHERE emp_id = p_emp_id;
END;
```

#### Exercise 4
Create a procedure to retrieve employee details by ID.

**Solution:**
```plsql
CREATE OR REPLACE PROCEDURE get_employee_details(
    p_emp_id IN NUMBER,
    p_emp_name OUT VARCHAR2,
    p_emp_salary OUT NUMBER
) IS
BEGIN
    SELECT emp_name, emp_salary
    INTO p_emp_name, p_emp_salary
    FROM employees
    WHERE emp_id = p_emp_id;
END;
```

#### Exercise 5
Create a procedure to raise an employee’s salary by a percentage.

**Solution:**
```plsql
CREATE OR REPLACE PROCEDURE raise_salary(
    p_emp_id IN NUMBER,
    p_percentage IN NUMBER
) IS
BEGIN
    UPDATE employees
    SET emp_salary = emp_salary * (1 + p_percentage / 100)
    WHERE emp_id = p_emp_id;
END;
```

#### Exercise 6
Create a procedure to log messages into an `audit_log` table.

**Supporting Data:**
```sql
CREATE TABLE audit_log (
    log_id NUMBER PRIMARY KEY,
    log_message VARCHAR2(255),
    log_date DATE
);
```

**Solution:**
```plsql
CREATE OR REPLACE PROCEDURE log_message(
    p_message IN VARCHAR2
) IS
BEGIN
    INSERT INTO audit_log (log_id, log_message, log_date)
    VALUES (audit_log_seq.NEXTVAL, p_message, SYSDATE);
END;
```

#### Exercise 7
Create a procedure to bulk insert data into the `employees` table from a temporary table.

**Supporting Data:**
```sql
CREATE TABLE temp_employees (
    emp_id NUMBER,
    emp_name VARCHAR2(100),
    emp_salary NUMBER
);
```

**Solution:**
```plsql
CREATE OR REPLACE PROCEDURE bulk_insert_employees AS
BEGIN
    INSERT INTO employees (emp_id, emp_name, emp_salary)
    SELECT emp_id, emp_name, emp_salary
    FROM temp_employees;
    
    -- Optionally, clear the temp table
    TRUNCATE TABLE temp_employees;
END;
```

#### Exercise 8
Create a procedure to validate employee data before insertion.

**Solution:**
```plsql
CREATE OR REPLACE PROCEDURE validate_and_insert_employee(
    p_emp_id IN NUMBER,
    p_emp_name IN VARCHAR2,
    p_emp_salary IN NUMBER
) IS
BEGIN
    IF p_emp_salary < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Salary cannot be negative');
    ELSE
        INSERT INTO employees (emp_id, emp_name, emp_salary)
        VALUES (p_emp_id, p_emp_name, p_emp_salary);
    END IF;
END;
```

#### Exercise 9
Create a procedure to fetch and display employee details using a cursor.

**Solution:**
```plsql
CREATE OR REPLACE PROCEDURE fetch_employee_details IS
    CURSOR emp_cursor IS
        SELECT emp_id, emp_name, emp_salary
        FROM employees;
BEGIN
    FOR emp_record IN emp_cursor LOOP
        DBMS_OUTPUT.PUT_LINE('ID: ' || emp_record.emp_id || ', Name: ' || emp_record.emp_name || ', Salary: ' || emp_record.emp_salary);
    END LOOP;
END;
```

#### Exercise 10
Create a procedure to handle exceptions and log them into an `error_log` table.

**Supporting Data:**
```sql
CREATE TABLE error_log (
    error_id NUMBER PRIMARY KEY,
    error_message VARCHAR2(255),
    error_date DATE
);
```

**Solution:**
```plsql
CREATE OR REPLACE PROCEDURE process_with_error_handling AS
BEGIN
    -- Sample code that might raise an exception
    RAISE NO_DATA_FOUND;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO error_log (error_id, error_message, error_date)
        VALUES (error_log_seq.NEXTVAL, SQLERRM, SYSDATE);
END;
```

---

### 09. Functions

#### Exercise 1
Create a function to calculate the total salary of employees.

**Solution:**
```plsql
CREATE OR REPLACE FUNCTION get_total_salary RETURN NUMBER IS
    v_total_salary NUMBER;
BEGIN
    SELECT SUM(emp_salary) INTO v_total_salary
    FROM employees;
    
    RETURN v_total_salary;
END;
```

#### Exercise 2
Create a function to return the employee name based on ID.

**Solution:**
```plsql
CREATE OR REPLACE FUNCTION get_employee_name(p_emp_id IN NUMBER) RETURN VARCHAR2 IS
    v_emp_name VARCHAR2(100);
BEGIN
    SELECT emp_name INTO v_emp_name
    FROM employees
    WHERE emp_id = p_emp_id;
    
    RETURN v_emp_name;
END;
```

#### Exercise 3
Create a function to calculate the average salary of employees.

**Solution:**
```plsql
CREATE OR REPLACE FUNCTION get_average_salary RETURN NUMBER IS
    v_avg_salary NUMBER;
BEGIN
    SELECT AVG(emp_salary) INTO v_avg_salary
    FROM employees;
    
    RETURN v_avg_salary;
END;
```

#### Exercise 4
Create a function to check if an employee exists by ID.

**Solution:**
```plsql
CREATE OR REPLACE FUNCTION employee_exists(p_emp_id IN NUMBER) RETURN BOOLEAN IS
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM employees
    WHERE emp_id = p_emp_id;
    
    RETURN v_count > 0;
END;
```

#### Exercise 5
Create a function to format an employee’s name in uppercase.

**Solution:**
```plsql
CREATE OR REPLACE FUNCTION format_employee_name(p_emp_id IN NUMBER) RETURN VARCHAR2 IS
    v_emp_name VARCHAR2(100);
BEGIN
    SELECT UPPER(emp_name) INTO v_emp_name
    FROM employees
    WHERE emp_id = p_emp_id;
    
    RETURN v_emp_name;
END;
```

#### Exercise 6
Create a function to return the highest salary among employees.

**Solution:**
```plsql
CREATE OR REPLACE FUNCTION get_highest_salary RETURN NUMBER IS
    v_highest_salary NUMBER;
BEGIN
    SELECT MAX(emp_salary) INTO v_highest_salary
    FROM employees;
    
    RETURN v_highest_salary;
END;
```

#### Exercise 7
Create a function to calculate the total number of employees.

**Solution:**
```plsql
CREATE OR REPLACE FUNCTION get_total_employees RETURN NUMBER IS
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM employees;
    
    RETURN v_count;
END;
```

#### Exercise 8
Create a function to determine the bonus for an employee based on salary.

**Solution:**
```plsql
CREATE OR REPLACE FUNCTION calculate_bonus(p_emp_id IN NUMBER) RETURN NUMBER IS
    v_salary NUMBER;
    v_bonus NUMBER;
BEGIN
    SELECT emp_salary INTO v_salary
    FROM employees
    WHERE emp_id = p_emp_id;
    
    v_bonus := v_salary * 0.10; -- 10% bonus
    
    RETURN v_bonus;
END;
```

#### Exercise 9
Create a function to return a formatted employee report.

**Solution:**
```plsql
CREATE OR REPLACE FUNCTION get_employee_report(p_emp_id IN NUMBER) RETURN VARCHAR2 IS
    v_emp_name VARCHAR2(100);
    v_emp_salary NUMBER;
    v_report VARCHAR2(255);
BEGIN
    SELECT emp_name, emp_salary INTO v_emp_name, v_emp_salary
    FROM employees
    WHERE emp_id = p_emp_id;
    
    v_report := 'Employee: ' || v_emp_name || ', Salary: ' || v_emp_salary;
    
    RETURN v_report;
END;
```

#### Exercise 10
Create a function to retrieve the department of an employee.

**Supporting Data:**
```sql
CREATE TABLE departments (
    dept_id NUMBER PRIMARY KEY,
   

 dept_name VARCHAR2(100)
);

ALTER TABLE employees ADD (dept_id NUMBER);
```

**Solution:**
```plsql
CREATE OR REPLACE FUNCTION get_employee_department(p_emp_id IN NUMBER) RETURN VARCHAR2 IS
    v_dept_name VARCHAR2(100);
BEGIN
    SELECT d.dept_name INTO v_dept_name
    FROM employees e
    JOIN departments d ON e.dept_id = d.dept_id
    WHERE e.emp_id = p_emp_id;
    
    RETURN v_dept_name;
END;
```

---

### 10. Packages

#### Exercise 1
Create a package to manage employee operations, including procedures for inserting, updating, and deleting.

**Solution:**
```plsql
CREATE OR REPLACE PACKAGE employee_pkg AS
    PROCEDURE insert_employee(p_emp_id IN NUMBER, p_emp_name IN VARCHAR2, p_emp_salary IN NUMBER);
    PROCEDURE update_salary(p_emp_id IN NUMBER, p_new_salary IN NUMBER);
    PROCEDURE delete_employee(p_emp_id IN NUMBER);
END employee_pkg;
/

CREATE OR REPLACE PACKAGE BODY employee_pkg AS
    PROCEDURE insert_employee(p_emp_id IN NUMBER, p_emp_name IN VARCHAR2, p_emp_salary IN NUMBER) IS
    BEGIN
        INSERT INTO employees (emp_id, emp_name, emp_salary) VALUES (p_emp_id, p_emp_name, p_emp_salary);
    END insert_employee;

    PROCEDURE update_salary(p_emp_id IN NUMBER, p_new_salary IN NUMBER) IS
    BEGIN
        UPDATE employees SET emp_salary = p_new_salary WHERE emp_id = p_emp_id;
    END update_salary;

    PROCEDURE delete_employee(p_emp_id IN NUMBER) IS
    BEGIN
        DELETE FROM employees WHERE emp_id = p_emp_id;
    END delete_employee;
END employee_pkg;
```

#### Exercise 2
Create a package to manage salary-related operations with functions to get total and average salary.

**Solution:**
```plsql
CREATE OR REPLACE PACKAGE salary_pkg AS
    FUNCTION get_total_salary RETURN NUMBER;
    FUNCTION get_average_salary RETURN NUMBER;
END salary_pkg;
/

CREATE OR REPLACE PACKAGE BODY salary_pkg AS
    FUNCTION get_total_salary RETURN NUMBER IS
        v_total_salary NUMBER;
    BEGIN
        SELECT SUM(emp_salary) INTO v_total_salary FROM employees;
        RETURN v_total_salary;
    END get_total_salary;

    FUNCTION get_average_salary RETURN NUMBER IS
        v_avg_salary NUMBER;
    BEGIN
        SELECT AVG(emp_salary) INTO v_avg_salary FROM employees;
        RETURN v_avg_salary;
    END get_average_salary;
END salary_pkg;
```

#### Exercise 3
Create a package with a procedure to log operations and a function to get the last log entry.

**Supporting Data:**
```sql
CREATE TABLE operation_log (
    log_id NUMBER PRIMARY KEY,
    log_message VARCHAR2(255),
    log_date DATE
);
```

**Solution:**
```plsql
CREATE OR REPLACE PACKAGE log_pkg AS
    PROCEDURE log_operation(p_message IN VARCHAR2);
    FUNCTION get_last_log RETURN VARCHAR2;
END log_pkg;
/

CREATE OR REPLACE PACKAGE BODY log_pkg AS
    PROCEDURE log_operation(p_message IN VARCHAR2) IS
    BEGIN
        INSERT INTO operation_log (log_id, log_message, log_date)
        VALUES (operation_log_seq.NEXTVAL, p_message, SYSDATE);
    END log_operation;

    FUNCTION get_last_log RETURN VARCHAR2 IS
        v_last_message VARCHAR2(255);
    BEGIN
        SELECT log_message INTO v_last_message
        FROM operation_log
        WHERE log_id = (SELECT MAX(log_id) FROM operation_log);
        
        RETURN v_last_message;
    END get_last_log;
END log_pkg;
```

#### Exercise 4
Create a package with a procedure to update employee details and a function to check if an employee exists.

**Solution:**
```plsql
CREATE OR REPLACE PACKAGE employee_management_pkg AS
    PROCEDURE update_employee(p_emp_id IN NUMBER, p_emp_name IN VARCHAR2, p_emp_salary IN NUMBER);
    FUNCTION employee_exists(p_emp_id IN NUMBER) RETURN BOOLEAN;
END employee_management_pkg;
/

CREATE OR REPLACE PACKAGE BODY employee_management_pkg AS
    PROCEDURE update_employee(p_emp_id IN NUMBER, p_emp_name IN VARCHAR2, p_emp_salary IN NUMBER) IS
    BEGIN
        UPDATE employees
        SET emp_name = p_emp_name, emp_salary = p_emp_salary
        WHERE emp_id = p_emp_id;
    END update_employee;

    FUNCTION employee_exists(p_emp_id IN NUMBER) RETURN BOOLEAN IS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count
        FROM employees
        WHERE emp_id = p_emp_id;
        
        RETURN v_count > 0;
    END employee_exists;
END employee_management_pkg;
```

#### Exercise 5
Create a package with a procedure to process employee bonuses and a function to calculate the bonus for a given employee.

**Solution:**
```plsql
CREATE OR REPLACE PACKAGE bonus_pkg AS
    PROCEDURE process_bonuses(p_percentage IN NUMBER);
    FUNCTION calculate_bonus(p_emp_id IN NUMBER) RETURN NUMBER;
END bonus_pkg;
/

CREATE OR REPLACE PACKAGE BODY bonus_pkg AS
    PROCEDURE process_bonuses(p_percentage IN NUMBER) IS
    BEGIN
        UPDATE employees
        SET emp_salary = emp_salary * (1 + p_percentage / 100);
    END process_bonuses;

    FUNCTION calculate_bonus(p_emp_id IN NUMBER) RETURN NUMBER IS
        v_salary NUMBER;
        v_bonus NUMBER;
    BEGIN
        SELECT emp_salary INTO v_salary
        FROM employees
        WHERE emp_id = p_emp_id;
        
        v_bonus := v_salary * 0.10; -- 10% bonus
        
        RETURN v_bonus;
    END calculate_bonus;
END bonus_pkg;
```

#### Exercise 6
Create a package to manage department operations with procedures to insert and delete departments and a function to get department details.

**Supporting Data:**
```sql
CREATE TABLE departments (
    dept_id NUMBER PRIMARY KEY,
    dept_name VARCHAR2(100)
);
```

**Solution:**
```plsql
CREATE OR REPLACE PACKAGE department_pkg AS
    PROCEDURE insert_department(p_dept_id IN NUMBER, p_dept_name IN VARCHAR2);
    PROCEDURE delete_department(p_dept_id IN NUMBER);
    FUNCTION get_department_name(p_dept_id IN NUMBER) RETURN VARCHAR2;
END department_pkg;
/

CREATE OR REPLACE PACKAGE BODY department_pkg AS
    PROCEDURE insert_department(p_dept_id IN NUMBER, p_dept_name IN VARCHAR2) IS
    BEGIN
        INSERT INTO departments (dept_id, dept_name)
        VALUES (p_dept_id, p_dept_name);
    END insert_department;

    PROCEDURE delete_department(p_dept_id IN NUMBER) IS
    BEGIN
        DELETE FROM departments
        WHERE dept_id = p_dept_id;
    END delete_department;

    FUNCTION get_department_name(p_dept_id IN NUMBER) RETURN VARCHAR2 IS
        v_dept_name VARCHAR2(100);
    BEGIN
        SELECT dept_name INTO v_dept_name
        FROM departments
        WHERE dept_id = p_dept_id;
        
        RETURN v_dept_name;
    END get_department_name;
END department_pkg;
```

#### Exercise 7
Create a package with procedures to manage employee status and a function to get employee status.

**Supporting Data:**
```sql
ALTER TABLE employees ADD (status VARCHAR2(20));
```

**Solution:**
```plsql
CREATE OR REPLACE PACKAGE status_pkg AS
    PROCEDURE set_employee_status(p_emp_id IN NUMBER, p_status IN VARCHAR2);
    FUNCTION get_employee_status(p_emp_id IN NUMBER) RETURN VARCHAR2;
END status_pkg;
/

CREATE OR REPLACE PACKAGE BODY status_pkg AS
    PROCEDURE set_employee_status(p_emp_id IN NUMBER, p_status IN VARCHAR2) IS
    BEGIN
        UPDATE employees
        SET status = p_status
        WHERE emp_id = p_emp_id;
    END set_employee_status;

    FUNCTION get_employee_status(p_emp_id IN NUMBER) RETURN VARCHAR2 IS
        v_status VARCHAR2(20);
    BEGIN
        SELECT status INTO v_status
        FROM employees
        WHERE emp_id = p_emp_id;
        
        RETURN v_status;
    END get_employee_status;
END status_pkg;
```

#### Exercise 8
Create a package to handle project data with procedures to add and remove projects and functions to retrieve project details.

**Supporting Data:**
```sql
CREATE TABLE projects (
    proj_id NUMBER PRIMARY KEY,
    proj_name VARCHAR2(100)
);
```

**Solution:**
```plsql
CREATE OR REPLACE PACKAGE project_pkg AS
    PROCEDURE add_project(p_proj_id IN NUMBER, p_proj_name IN VARCHAR2);
    PROCEDURE remove_project(p_proj_id IN NUMBER);
    FUNCTION get_project_name(p_proj_id IN NUMBER) RETURN VARCHAR2;
END project_pkg;
/

CREATE OR REPLACE PACKAGE BODY project_pkg AS
    PROCEDURE add_project(p_proj_id IN NUMBER, p_proj_name IN VARCHAR2) IS
    BEGIN
        INSERT INTO projects (proj_id, proj_name)
        VALUES (p_proj_id, p_proj_name);
    END add_project;

    PROCEDURE remove_project(p_proj_id IN NUMBER) IS
    BEGIN
        DELETE FROM projects
        WHERE proj_id = p_proj_id;
    END remove_project;

    FUNCTION get_project_name(p_proj_id IN NUMBER) RETURN VARCHAR2 IS
        v_proj_name VARCHAR2(100);
    BEGIN
        SELECT proj_name INTO v_proj_name
        FROM projects
        WHERE proj_id = p_proj_id;
        
        RETURN v_proj_name;
    END get_project_name;
END project_pkg;
```

#### Exercise 9
Create a package with a procedure to log errors and a function to retrieve the most recent error message.

**Supporting Data:**
```sql
CREATE TABLE error

_log (
    error_id NUMBER PRIMARY KEY,
    error_message VARCHAR2(255),
    error_date DATE
);
```

**Solution:**
```plsql
CREATE OR REPLACE PACKAGE error_log_pkg AS
    PROCEDURE log_error(p_message IN VARCHAR2);
    FUNCTION get_latest_error RETURN VARCHAR2;
END error_log_pkg;
/

CREATE OR REPLACE PACKAGE BODY error_log_pkg AS
    PROCEDURE log_error(p_message IN VARCHAR2) IS
    BEGIN
        INSERT INTO error_log (error_id, error_message, error_date)
        VALUES (error_log_seq.NEXTVAL, p_message, SYSDATE);
    END log_error;

    FUNCTION get_latest_error RETURN VARCHAR2 IS
        v_latest_error VARCHAR2(255);
    BEGIN
        SELECT error_message INTO v_latest_error
        FROM error_log
        WHERE error_id = (SELECT MAX(error_id) FROM error_log);
        
        RETURN v_latest_error;
    END get_latest_error;
END error_log_pkg;
```

#### Exercise 10
Create a package for managing user accounts with procedures to create and delete users and a function to check if a user exists.

**Supporting Data:**
```sql
CREATE TABLE user_accounts (
    user_id NUMBER PRIMARY KEY,
    user_name VARCHAR2(100)
);
```

**Solution:**
```plsql
CREATE OR REPLACE PACKAGE user_pkg AS
    PROCEDURE create_user(p_user_id IN NUMBER, p_user_name IN VARCHAR2);
    PROCEDURE delete_user(p_user_id IN NUMBER);
    FUNCTION user_exists(p_user_id IN NUMBER) RETURN BOOLEAN;
END user_pkg;
/

CREATE OR REPLACE PACKAGE BODY user_pkg AS
    PROCEDURE create_user(p_user_id IN NUMBER, p_user_name IN VARCHAR2) IS
    BEGIN
        INSERT INTO user_accounts (user_id, user_name)
        VALUES (p_user_id, p_user_name);
    END create_user;

    PROCEDURE delete_user(p_user_id IN NUMBER) IS
    BEGIN
        DELETE FROM user_accounts
        WHERE user_id = p_user_id;
    END delete_user;

    FUNCTION user_exists(p_user_id IN NUMBER) RETURN BOOLEAN IS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count
        FROM user_accounts
        WHERE user_id = p_user_id;
        
        RETURN v_count > 0;
    END user_exists;
END user_pkg;
```

---

### 11. Triggers

#### Exercise 1
Create a trigger to automatically update a timestamp column `last_updated` on any update to the `employees` table.

**Supporting Data:**
```sql
ALTER TABLE employees ADD (last_updated TIMESTAMP);
```

**Solution:**
```plsql
CREATE OR REPLACE TRIGGER trg_update_timestamp
BEFORE UPDATE ON employees
FOR EACH ROW
BEGIN
    :NEW.last_updated := SYSTIMESTAMP;
END;
```

#### Exercise 2
Create a trigger to insert a record into an `audit_log` table whenever a new record is inserted into the `employees` table.

**Supporting Data:**
```sql
CREATE TABLE audit_log (
    log_id NUMBER PRIMARY KEY,
    action VARCHAR2(50),
    action_date TIMESTAMP
);
```

**Solution:**
```plsql
CREATE OR REPLACE TRIGGER trg_employee_insert
AFTER INSERT ON employees
FOR EACH ROW
BEGIN
    INSERT INTO audit_log (log_id, action, action_date)
    VALUES (audit_log_seq.NEXTVAL, 'INSERT Employee: ' || :NEW.emp_name, SYSTIMESTAMP);
END;
```

#### Exercise 3
Create a trigger to prevent deletion of employees if they are assigned to a project.

**Supporting Data:**
```sql
ALTER TABLE employees ADD (proj_id NUMBER);
```

**Solution:**
```plsql
CREATE OR REPLACE TRIGGER trg_prevent_employee_delete
BEFORE DELETE ON employees
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM projects
    WHERE proj_id = :OLD.proj_id;
    
    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Cannot delete employee assigned to a project.');
    END IF;
END;
```

#### Exercise 4
Create a trigger to log changes to the `salary` column in the `employees` table into an `salary_log` table.

**Supporting Data:**
```sql
CREATE TABLE salary_log (
    log_id NUMBER PRIMARY KEY,
    emp_id NUMBER,
    old_salary NUMBER,
    new_salary NUMBER,
    change_date TIMESTAMP
);
```

**Solution:**
```plsql
CREATE OR REPLACE TRIGGER trg_salary_log
AFTER UPDATE OF emp_salary ON employees
FOR EACH ROW
BEGIN
    INSERT INTO salary_log (log_id, emp_id, old_salary, new_salary, change_date)
    VALUES (salary_log_seq.NEXTVAL, :OLD.emp_id, :OLD.emp_salary, :NEW.emp_salary, SYSTIMESTAMP);
END;
```

#### Exercise 5
Create a trigger to automatically populate a `status` column in the `employees` table based on the `emp_salary`.

**Supporting Data:**
```sql
ALTER TABLE employees ADD (status VARCHAR2(20));
```

**Solution:**
```plsql
CREATE OR REPLACE TRIGGER trg_salary_status
BEFORE INSERT OR UPDATE ON employees
FOR EACH ROW
BEGIN
    IF :NEW.emp_salary < 50000 THEN
        :NEW.status := 'Junior';
    ELSE
        :NEW.status := 'Senior';
    END IF;
END;
```

#### Exercise 6
Create a trigger to prevent updates to the `emp_name` column if the employee is a manager.

**Supporting Data:**
```sql
ALTER TABLE employees ADD (is_manager CHAR(1));
```

**Solution:**
```plsql
CREATE OR REPLACE TRIGGER trg_prevent_name_update
BEFORE UPDATE OF emp_name ON employees
FOR EACH ROW
BEGIN
    IF :OLD.is_manager = 'Y' THEN
        RAISE_APPLICATION_ERROR(-20002, 'Cannot update name for managers.');
    END IF;
END;
```

#### Exercise 7
Create a trigger to automatically update the `last_updated` timestamp on changes to the `employees` table.

**Solution:**
```plsql
CREATE OR REPLACE TRIGGER trg_auto_update_timestamp
BEFORE UPDATE ON employees
FOR EACH ROW
BEGIN
    :NEW.last_updated := SYSTIMESTAMP;
END;
```

#### Exercise 8
Create a trigger to check for valid department IDs before inserting into the `employees` table.

**Solution:**
```plsql
CREATE OR REPLACE TRIGGER trg_check_dept_id
BEFORE INSERT ON employees
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM departments
    WHERE dept_id = :NEW.dept_id;
    
    IF v_count = 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'Invalid department ID.');
    END IF;
END;
```

#### Exercise 9
Create a trigger to automatically update the `total_employees` in a summary table whenever a new employee is added.

**Supporting Data:**
```sql
CREATE TABLE employee_summary (
    total_employees NUMBER
);
```

**Solution:**
```plsql
CREATE OR REPLACE TRIGGER trg_update_employee_summary
AFTER INSERT ON employees
FOR EACH ROW
BEGIN
    UPDATE employee_summary
    SET total_employees = total_employees + 1;
END;
```

#### Exercise 10
Create a trigger to log all updates made to the `employees` table.

**Solution:**
```plsql
CREATE OR REPLACE TRIGGER trg_log_employee_updates
AFTER UPDATE ON employees
FOR EACH ROW
BEGIN
    INSERT INTO audit_log (log_id, action, action_date)
    VALUES (audit_log_seq.NEXTVAL, 'Updated Employee ID: ' || :NEW.emp_id, SYSTIMESTAMP);
END;
```

---

### 12. Collections

#### Exercise 1
Create a PL/SQL block using an associative array to store employee IDs and names.

**Solution:**
```plsql
DECLARE
    TYPE emp_table IS TABLE OF VARCHAR2(100) INDEX BY NUMBER;
    emp_names emp_table;
BEGIN
    emp_names(1) := 'John Doe';
    emp_names(2) := 'Jane Smith';
    
    DBMS_OUTPUT.PUT_LINE('Employee 1: ' || emp_names(1));
    DBMS_OUTPUT.PUT_LINE('Employee 2: ' || emp_names(2));
END;
```

#### Exercise 2
Create a PL/SQL block using a nested table to store employee salaries.

**Solution:**
```plsql
DECLARE
    TYPE salary_table IS TABLE OF NUMBER;
    salaries salary_table := salary_table();
BEGIN
    salaries.EXTEND(2);
    salaries(1) := 50000;
    salaries(2) := 60000;
    
    DBMS_OUTPUT.PUT_LINE('Salary 1: ' || salaries(1));
    DBMS_OUTPUT.PUT_LINE('Salary 2: ' || salaries(2));
END;
```

#### Exercise 3
Create a PL/SQL block using a varray to store employee names with a maximum of 5 names.

**Solution:**
```plsql
DECLARE
    TYPE name_array IS VARRAY(5) OF VARCHAR2(100);
    employee_names name_array := name_array('John', 'Jane', 'Jim', 'Jill', 'Jack');
BEGIN
    FOR i IN 1..employee_names.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Employee ' || i || ': ' || employee_names(i));
    END LOOP;
END;
```

#### Exercise 4
Create a procedure that uses a PL/SQL table to process and print employee salaries.

**Solution:**
```plsql
CREATE

 OR REPLACE PROCEDURE print_salaries IS
    TYPE salary_table IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    salaries salary_table;
BEGIN
    salaries(1) := 50000;
    salaries(2) := 60000;
    salaries(3) := 70000;
    
    FOR i IN salaries.FIRST .. salaries.LAST LOOP
        DBMS_OUTPUT.PUT_LINE('Salary ' || i || ': ' || salaries(i));
    END LOOP;
END;
```

#### Exercise 5
Create a PL/SQL block using a record to store and display employee details.

**Solution:**
```plsql
DECLARE
    TYPE emp_record IS RECORD (
        emp_id NUMBER,
        emp_name VARCHAR2(100),
        emp_salary NUMBER
    );
    emp emp_record;
BEGIN
    emp.emp_id := 1;
    emp.emp_name := 'John Doe';
    emp.emp_salary := 50000;
    
    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || emp.emp_id);
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || emp.emp_name);
    DBMS_OUTPUT.PUT_LINE('Employee Salary: ' || emp.emp_salary);
END;
```

#### Exercise 6
Create a PL/SQL block that uses a cursor to fetch and display employee data from a table.

**Solution:**
```plsql
DECLARE
    CURSOR emp_cursor IS
        SELECT emp_id, emp_name, emp_salary
        FROM employees;
        
    emp_record employees%ROWTYPE;
BEGIN
    OPEN emp_cursor;
    LOOP
        FETCH emp_cursor INTO emp_record;
        EXIT WHEN emp_cursor%NOTFOUND;
        
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || emp_record.emp_id);
        DBMS_OUTPUT.PUT_LINE('Employee Name: ' || emp_record.emp_name);
        DBMS_OUTPUT.PUT_LINE('Employee Salary: ' || emp_record.emp_salary);
    END LOOP;
    CLOSE emp_cursor;
END;
```

#### Exercise 7
Create a procedure to process a collection of employee IDs and print them.

**Solution:**
```plsql
CREATE OR REPLACE PROCEDURE print_emp_ids(p_emp_ids IN SYS.ODCINUMBERLIST) IS
BEGIN
    FOR i IN 1 .. p_emp_ids.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || p_emp_ids(i));
    END LOOP;
END;
```

#### Exercise 8
Create a PL/SQL block that uses a bulk collect to fetch and display employee data.

**Solution:**
```plsql
DECLARE
    TYPE emp_table IS TABLE OF employees%ROWTYPE;
    emp_data emp_table;
BEGIN
    SELECT * BULK COLLECT INTO emp_data
    FROM employees;
    
    FOR i IN 1 .. emp_data.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || emp_data(i).emp_id);
        DBMS_OUTPUT.PUT_LINE('Employee Name: ' || emp_data(i).emp_name);
        DBMS_OUTPUT.PUT_LINE('Employee Salary: ' || emp_data(i).emp_salary);
    END LOOP;
END;
```

#### Exercise 9
Create a PL/SQL block that uses a REF CURSOR to fetch and display employee data.

**Solution:**
```plsql
DECLARE
    TYPE ref_cursor IS REF CURSOR;
    emp_cursor ref_cursor;
    emp_record employees%ROWTYPE;
BEGIN
    OPEN emp_cursor FOR
        SELECT * FROM employees;
        
    LOOP
        FETCH emp_cursor INTO emp_record;
        EXIT WHEN emp_cursor%NOTFOUND;
        
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || emp_record.emp_id);
        DBMS_OUTPUT.PUT_LINE('Employee Name: ' || emp_record.emp_name);
        DBMS_OUTPUT.PUT_LINE('Employee Salary: ' || emp_record.emp_salary);
    END LOOP;
    CLOSE emp_cursor;
END;
```

#### Exercise 10
Create a procedure to return a nested table of employee names.

**Solution:**
```plsql
CREATE OR REPLACE FUNCTION get_emp_names RETURN SYS.ODCIVARCHAR2LIST IS
    emp_names SYS.ODCIVARCHAR2LIST := SYS.ODCIVARCHAR2LIST();
BEGIN
    SELECT emp_name BULK COLLECT INTO emp_names
    FROM employees;
    
    RETURN emp_names;
END;
```

