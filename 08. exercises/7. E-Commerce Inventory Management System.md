## **Project: E-Commerce Inventory Management System**

### **1. Schema Setup**

**1.1. Tables**

```sql

-- Products Table
CREATE TABLE Products (
    ProductID NUMBER PRIMARY KEY,
    ProductName VARCHAR2(100) NOT NULL,
    Price NUMBER NOT NULL,
    StockQuantity NUMBER
);

-- Orders Table
CREATE TABLE Orders (
    OrderID NUMBER PRIMARY KEY,
    OrderDate DATE DEFAULT SYSDATE,
    CustomerName VARCHAR2(100),
    TotalAmount NUMBER
);

-- OrderItems Table
CREATE TABLE OrderItems (
    OrderItemID NUMBER PRIMARY KEY,
    OrderID NUMBER,
    ProductID NUMBER,
    Quantity NUMBER,
    FOREIGN KEY (OrderID) REFERENCES Orders(OrderID),
    FOREIGN KEY (ProductID) REFERENCES Products(ProductID)
);

-- StockMovements Table
CREATE TABLE StockMovements (
    MovementID NUMBER PRIMARY KEY,
    ProductID NUMBER,
    MovementDate DATE DEFAULT SYSDATE,
    Quantity NUMBER,
    MovementType VARCHAR2(50), -- 'IN' or 'OUT'
    FOREIGN KEY (ProductID) REFERENCES Products(ProductID)
);


-- Additional Table: Categories
CREATE TABLE Categories (
    CategoryID NUMBER PRIMARY KEY,
    CategoryName VARCHAR2(100)
);

-- Additional Table: ProductCategories
CREATE TABLE ProductCategories (
    ProductID NUMBER,
    CategoryID NUMBER,
    FOREIGN KEY (ProductID) REFERENCES Products(ProductID),
    FOREIGN KEY (CategoryID) REFERENCES Categories(CategoryID)
);
```

**1.2. Sample Data**

```sql

-- Insert sample products
INSERT INTO Products (ProductID, ProductName, Price, StockQuantity) VALUES (1, 'Laptop', 1000, 50);
INSERT INTO Products (ProductID, ProductName, Price, StockQuantity) VALUES (2, 'Phone', 600, 100);
INSERT INTO Products (ProductID, ProductName, Price, StockQuantity) VALUES (3, 'Tablet', 300, 75);

-- Insert sample orders
INSERT INTO Orders (OrderID, CustomerName, TotalAmount) VALUES (1001, 'John Doe', 1600);
INSERT INTO Orders (OrderID, CustomerName, TotalAmount) VALUES (1002, 'Jane Smith', 900);

-- Insert sample order items
INSERT INTO OrderItems (OrderItemID, OrderID, ProductID, Quantity) VALUES (1, 1001, 1, 1);
INSERT INTO OrderItems (OrderItemID, OrderID, ProductID, Quantity) VALUES (2, 1001, 2, 1);
INSERT INTO OrderItems (OrderItemID, OrderID, ProductID, Quantity) VALUES (3, 1002, 2, 1);
INSERT INTO OrderItems (OrderItemID, OrderID, ProductID, Quantity) VALUES (4, 1002, 3, 2);


-- Insert sample categories
INSERT INTO Categories (CategoryID, CategoryName) VALUES (1, 'Electronics');
INSERT INTO Categories (CategoryID, CategoryName) VALUES (2, 'Mobile Phones');
INSERT INTO Categories (CategoryID, CategoryName) VALUES (3, 'Computers');

-- Insert product categories
INSERT INTO ProductCategories (ProductID, CategoryID) VALUES (1, 3);
INSERT INTO ProductCategories (ProductID, CategoryID) VALUES (2, 2);
INSERT INTO ProductCategories (ProductID, CategoryID) VALUES (3, 1);

-- Additional sample data for orders
INSERT INTO Orders (OrderID, CustomerName, TotalAmount) VALUES (1003, 'Alice Johnson', 1200);
INSERT INTO Orders (OrderID, CustomerName, TotalAmount) VALUES (1004, 'Bob Brown', 700);

-- Additional sample data for order items
INSERT INTO OrderItems (OrderItemID, OrderID, ProductID, Quantity) VALUES (5, 1003, 1, 1);
INSERT INTO OrderItems (OrderItemID, OrderID, ProductID, Quantity) VALUES (6, 1003, 3, 2);
INSERT INTO OrderItems (OrderItemID, OrderID, ProductID, Quantity) VALUES (7, 1004, 2, 1);
INSERT INTO OrderItems (OrderItemID, OrderID, ProductID, Quantity) VALUES (8, 1004, 3, 1);
```

### **2. PL/SQL Components**

**2.1. Procedures**

```sql
-- Procedure to delete an order
CREATE OR REPLACE PROCEDURE DeleteOrder (p_order_id IN NUMBER) AS
BEGIN
    -- Delete order items first
    DELETE FROM OrderItems WHERE OrderID = p_order_id;
    
    -- Delete the order
    DELETE FROM Orders WHERE OrderID = p_order_id;
    
    DBMS_OUTPUT.PUT_LINE('Order ' || p_order_id || ' deleted successfully.');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error deleting order: ' || SQLERRM);
END DeleteOrder;

-- Procedure to update product price
CREATE OR REPLACE PROCEDURE UpdateProductPrice (
    p_product_id IN NUMBER,
    p_new_price IN NUMBER
) AS
BEGIN
    UPDATE Products
    SET Price = p_new_price
    WHERE ProductID = p_product_id;
    
    DBMS_OUTPUT.PUT_LINE('Updated Product ID ' || p_product_id || ' to new price: ' || p_new_price);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Product ID ' || p_product_id || ' not found.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error updating product price: ' || SQLERRM);
END UpdateProductPrice;

-- Procedure to restock a product
CREATE OR REPLACE PROCEDURE RestockProduct (
    p_product_id IN NUMBER,
    p_quantity IN NUMBER
) AS
BEGIN
    -- Add quantity to stock
    UPDATE Products
    SET StockQuantity = StockQuantity + p_quantity
    WHERE ProductID = p_product_id;
    
    -- Log the stock movement
    INSERT INTO StockMovements (ProductID, Quantity, MovementType) VALUES (p_product_id, p_quantity, 'IN');
    
    DBMS_OUTPUT.PUT_LINE('Restocked Product ID ' || p_product_id || ' with quantity: ' || p_quantity);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error restocking product: ' || SQLERRM);
END RestockProduct;

-- Procedure to create a category
CREATE OR REPLACE PROCEDURE CreateCategory (
    p_category_name IN VARCHAR2
) AS
    v_category_id NUMBER;
BEGIN
    INSERT INTO Categories (CategoryName) VALUES (p_category_name)
    RETURNING CategoryID INTO v_category_id;
    
    DBMS_OUTPUT.PUT_LINE('Category created with ID: ' || v_category_id);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error creating category: ' || SQLERRM);
END CreateCategory;

-- Procedure to associate product with category
CREATE OR REPLACE PROCEDURE AssociateProductCategory (
    p_product_id IN NUMBER,
    p_category_id IN NUMBER
) AS
BEGIN
    INSERT INTO ProductCategories (ProductID, CategoryID) VALUES (p_product_id, p_category_id);
    DBMS_OUTPUT.PUT_LINE('Product ID ' || p_product_id || ' associated with Category ID ' || p_category_id);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error associating product with category: ' || SQLERRM);
END AssociateProductCategory;

-- Procedure to remove product from category
CREATE OR REPLACE PROCEDURE RemoveProductFromCategory (
    p_product_id IN NUMBER,
    p_category_id IN NUMBER
) AS
BEGIN
    DELETE FROM ProductCategories WHERE ProductID = p_product_id AND CategoryID = p_category_id;
    DBMS_OUTPUT.PUT_LINE('Product ID ' || p_product_id || ' removed from Category ID ' || p_category_id);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error removing product from category: ' || SQLERRM);
END RemoveProductFromCategory;

-- Procedure to fetch top N products by stock quantity
CREATE OR REPLACE PROCEDURE FetchTopNProducts (
    p_limit IN NUMBER,
    p_cursor OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_cursor FOR
        SELECT ProductID, ProductName, StockQuantity
        FROM Products
        ORDER BY StockQuantity DESC
        FETCH FIRST p_limit ROWS ONLY;
END FetchTopNProducts;

-- Procedure to fetch orders for a specific customer
CREATE OR REPLACE PROCEDURE FetchCustomerOrders (
    p_customer_name IN VARCHAR2,
    p_cursor OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_cursor FOR
        SELECT * FROM Orders
        WHERE CustomerName = p_customer_name;
END FetchCustomerOrders;

-- Procedure to update order total
CREATE OR REPLACE PROCEDURE UpdateOrderTotal (
    p_order_id IN NUMBER
) AS
    v_total_amount NUMBER := 0;
BEGIN
    -- Calculate total amount for the order
    SELECT SUM(oi.Quantity * p.Price)
    INTO v_total_amount
    FROM OrderItems oi
    JOIN Products p ON oi.ProductID = p.ProductID
    WHERE oi.OrderID = p_order_id;
    
    -- Update order total amount
    UPDATE Orders
    SET TotalAmount = v_total_amount
    WHERE OrderID = p_order_id;
    
    DBMS_OUTPUT.PUT_LINE('Updated total amount for Order ID ' || p_order_id || ': ' || v_total_amount);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error updating order total: ' || SQLERRM);
END UpdateOrderTotal;

-- Procedure to delete stock movements for a product
CREATE OR REPLACE PROCEDURE DeleteStockMovements (
    p_product_id IN NUMBER
) AS
BEGIN
    DELETE FROM StockMovements WHERE ProductID = p_product_id;
    DBMS_OUTPUT.PUT_LINE('Deleted stock movements for Product ID ' || p_product_id);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error deleting stock movements: ' || SQLERRM);
END DeleteStockMovements;
```

**2.2. Functions**

```sql
-- Function to get product details by name
CREATE OR REPLACE FUNCTION GetProductDetails (
    p_product_name IN VARCHAR2
) RETURN SYS_REFCURSOR AS
    v_cursor SYS_REFCURSOR;
BEGIN
    OPEN v_cursor FOR
        SELECT * FROM Products
        WHERE ProductName = p_product_name;
    RETURN v_cursor;
END GetProductDetails;

-- Function to calculate discount on a product
CREATE OR REPLACE FUNCTION CalculateDiscount (
    p_product_id IN NUMBER,
    p_discount_percent IN NUMBER
) RETURN NUMBER AS
    v_price NUMBER;
    v_discounted_price NUMBER;
BEGIN
    SELECT Price INTO v_price FROM Products WHERE ProductID = p_product_id;
    v_discounted_price := v_price - (v_price * p_discount_percent / 100);
    RETURN v_discounted_price;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
END CalculateDiscount;

-- Function to get total number of orders for a product
CREATE OR REPLACE FUNCTION GetTotalOrdersForProduct (
    p_product_id IN NUMBER
) RETURN NUMBER AS
    v_order_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_order_count
    FROM OrderItems
    WHERE ProductID = p_product_id;
    RETURN v_order_count;
EXCEPTION
    WHEN OTHERS THEN
        RETURN 0;
END GetTotalOrdersForProduct;

-- Function to check stock availability
CREATE OR REPLACE FUNCTION CheckStockAvailability (
    p_product_id IN NUMBER,
    p_required_quantity IN NUMBER
) RETURN BOOLEAN AS
    v_stock_quantity NUMBER;
BEGIN
    SELECT StockQuantity INTO v_stock_quantity FROM Products WHERE ProductID = p_product_id;
    RETURN v_stock_quantity >= p_required_quantity;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN FALSE;
END CheckStockAvailability;

-- Function

 to calculate order total
CREATE OR REPLACE FUNCTION CalculateOrderTotal (
    p_order_id IN NUMBER
) RETURN NUMBER AS
    v_total_amount NUMBER;
BEGIN
    SELECT SUM(oi.Quantity * p.Price)
    INTO v_total_amount
    FROM OrderItems oi
    JOIN Products p ON oi.ProductID = p.ProductID
    WHERE oi.OrderID = p_order_id;
    RETURN v_total_amount;
EXCEPTION
    WHEN OTHERS THEN
        RETURN 0;
END CalculateOrderTotal;

-- Function to get most expensive product
CREATE OR REPLACE FUNCTION GetMostExpensiveProduct RETURN Products%ROWTYPE AS
    v_product Products%ROWTYPE;
BEGIN
    SELECT * INTO v_product
    FROM Products
    ORDER BY Price DESC
    FETCH FIRST ROW ONLY;
    RETURN v_product;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
END GetMostExpensiveProduct;

-- Function to get average stock quantity
CREATE OR REPLACE FUNCTION GetAverageStockQuantity RETURN NUMBER AS
    v_avg_stock NUMBER;
BEGIN
    SELECT AVG(StockQuantity) INTO v_avg_stock FROM Products;
    RETURN v_avg_stock;
EXCEPTION
    WHEN OTHERS THEN
        RETURN 0;
END GetAverageStockQuantity;

-- Function to get order status
CREATE OR REPLACE FUNCTION GetOrderStatus (
    p_order_id IN NUMBER
) RETURN VARCHAR2 AS
    v_status VARCHAR2(50);
BEGIN
    SELECT Status INTO v_status FROM Orders WHERE OrderID = p_order_id;
    RETURN v_status;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 'Unknown';
END GetOrderStatus;

-- Function to get product category
CREATE OR REPLACE FUNCTION GetProductCategory (
    p_product_id IN NUMBER
) RETURN VARCHAR2 AS
    v_category_name VARCHAR2(100);
BEGIN
    SELECT c.CategoryName
    INTO v_category_name
    FROM ProductCategories pc
    JOIN Categories c ON pc.CategoryID = c.CategoryID
    WHERE pc.ProductID = p_product_id;
    RETURN v_category_name;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 'No Category';
END GetProductCategory;

-- Function to get discount percentage for a product
CREATE OR REPLACE FUNCTION GetDiscountPercentage (
    p_product_id IN NUMBER
) RETURN NUMBER AS
    v_discount_percentage NUMBER;
BEGIN
    SELECT DiscountPercentage INTO v_discount_percentage FROM Products WHERE ProductID = p_product_id;
    RETURN v_discount_percentage;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
END GetDiscountPercentage;
```

**2.3. Packages**

```sql
-- Package Specification
CREATE OR REPLACE PACKAGE ProductPackage AS
    PROCEDURE AddProduct (p_name IN VARCHAR2, p_price IN NUMBER, p_stock IN NUMBER);
    FUNCTION GetProductPrice (p_product_id IN NUMBER) RETURN NUMBER;
    PROCEDURE UpdateStock (p_product_id IN NUMBER, p_quantity IN NUMBER);
    FUNCTION GetProductStock (p_product_id IN NUMBER) RETURN NUMBER;
END ProductPackage;

-- Package Body
CREATE OR REPLACE PACKAGE BODY ProductPackage AS

    PROCEDURE AddProduct (
        p_name IN VARCHAR2,
        p_price IN NUMBER,
        p_stock IN NUMBER
    ) AS
    BEGIN
        INSERT INTO Products (ProductName, Price, StockQuantity) VALUES (p_name, p_price, p_stock);
        DBMS_OUTPUT.PUT_LINE('Product ' || p_name || ' added successfully.');
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Error adding product: ' || SQLERRM);
    END AddProduct;

    FUNCTION GetProductPrice (
        p_product_id IN NUMBER
    ) RETURN NUMBER AS
        v_price NUMBER;
    BEGIN
        SELECT Price INTO v_price FROM Products WHERE ProductID = p_product_id;
        RETURN v_price;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 0;
    END GetProductPrice;

    PROCEDURE UpdateStock (
        p_product_id IN NUMBER,
        p_quantity IN NUMBER
    ) AS
    BEGIN
        UPDATE Products SET StockQuantity = StockQuantity + p_quantity WHERE ProductID = p_product_id;
        DBMS_OUTPUT.PUT_LINE('Updated stock for Product ID ' || p_product_id || ' by quantity: ' || p_quantity);
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Error updating stock: ' || SQLERRM);
    END UpdateStock;

    FUNCTION GetProductStock (
        p_product_id IN NUMBER
    ) RETURN NUMBER AS
        v_stock NUMBER;
    BEGIN
        SELECT StockQuantity INTO v_stock FROM Products WHERE ProductID = p_product_id;
        RETURN v_stock;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 0;
    END GetProductStock;

END ProductPackage;
```

**2.4. Triggers**

```sql
-- Trigger to update stock movements on product update
CREATE OR REPLACE TRIGGER trg_update_stock_movements
AFTER UPDATE OF StockQuantity ON Products
FOR EACH ROW
BEGIN
    IF :OLD.StockQuantity < :NEW.StockQuantity THEN
        INSERT INTO StockMovements (ProductID, Quantity, MovementType) 
        VALUES (:NEW.ProductID, :NEW.StockQuantity - :OLD.StockQuantity, 'IN');
    ELSE
        INSERT INTO StockMovements (ProductID, Quantity, MovementType) 
        VALUES (:NEW.ProductID, :OLD.StockQuantity - :NEW.StockQuantity, 'OUT');
    END IF;
END;

-- Trigger to auto-calculate order total on order item insertion
CREATE OR REPLACE TRIGGER trg_auto_calculate_order_total
AFTER INSERT ON OrderItems
FOR EACH ROW
BEGIN
    UPDATE Orders
    SET TotalAmount = (
        SELECT SUM(oi.Quantity * p.Price)
        FROM OrderItems oi
        JOIN Products p ON oi.ProductID = p.ProductID
        WHERE oi.OrderID = :NEW.OrderID
    )
    WHERE OrderID = :NEW.OrderID;
END;

-- Trigger to prevent negative stock quantities
CREATE OR REPLACE TRIGGER trg_prevent_negative_stock
BEFORE UPDATE OF StockQuantity ON Products
FOR EACH ROW
BEGIN
    IF :NEW.StockQuantity < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Stock quantity cannot be negative.');
    END IF;
END;

-- Trigger to log deletion of orders
CREATE OR REPLACE TRIGGER trg_log_order_deletion
AFTER DELETE ON Orders
FOR EACH ROW
BEGIN
    INSERT INTO OrderDeletionLog (OrderID, DeletionDate)
    VALUES (:OLD.OrderID, SYSDATE);
END;

-- Trigger to set default values for new products
CREATE OR REPLACE TRIGGER trg_set_default_product_values
BEFORE INSERT ON Products
FOR EACH ROW
BEGIN
    IF :NEW.Price IS NULL THEN
        :NEW.Price := 0;
    END IF;
    IF :NEW.StockQuantity IS NULL THEN
        :NEW.StockQuantity := 0;
    END IF;
END;
```

**2.5. Exception Handling**

```sql
-- Procedure with exception handling
CREATE OR REPLACE PROCEDURE ProcessOrder (
    p_order_id IN NUMBER
) AS
BEGIN
    -- Fetch order details
    SELECT * INTO v_order
    FROM Orders
    WHERE OrderID = p_order_id;
    
    -- Process order (dummy operation)
    DBMS_OUTPUT.PUT_LINE('Processing Order ID: ' || p_order_id);
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Order ID ' || p_order_id || ' not found.');
    WHEN VALUE_ERROR THEN
        DBMS_OUTPUT.PUT_LINE('Value error processing Order ID ' || p_order_id);
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Unexpected error: ' || SQLERRM);
END ProcessOrder;

-- Function with exception handling
CREATE OR REPLACE FUNCTION SafeDivide (
    p_numerator IN NUMBER,
    p_denominator IN NUMBER
) RETURN NUMBER AS
BEGIN
    RETURN p_numerator / p_denominator;
EXCEPTION
    WHEN ZERO_DIVIDE THEN
        RETURN NULL; -- Handle divide-by-zero error
    WHEN OTHERS THEN
        RETURN NULL; -- Handle other unexpected errors
END SafeDivide;
```

**2.6. Collections**

```sql
-- Collection types
CREATE OR REPLACE TYPE ProductTableType AS TABLE OF Products%ROWTYPE;

-- Procedure using collections
CREATE OR REPLACE PROCEDURE ProcessProducts (
    p_product_table IN ProductTableType
) AS
BEGIN
    FOR i IN 1..p_product_table.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Processing Product ID: ' || p_product_table(i).ProductID || ', Name: ' || p_product_table(i).ProductName);
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error processing products: ' || SQLERRM);
END ProcessProducts;
```

**2.7. REF CURSORS**

```sql
-- Procedure with REF CURSOR
CREATE OR REPLACE PROCEDURE GetProductDetailsByCategory (
    p_category_name IN VARCHAR2,
    p_cursor OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_cursor FOR
        SELECT p.ProductID, p.ProductName, p.Price
        FROM Products p
        JOIN ProductCategories pc ON p.ProductID = pc.ProductID
        JOIN Categories c ON pc.CategoryID = c.CategoryID
        WHERE c.CategoryName = p_category_name;
END GetProductDetailsByCategory;

-- Procedure to fetch product details using REF CURSOR
CREATE OR REPLACE PROCEDURE DisplayProducts (
    p_cursor IN SYS_REFCURSOR
) AS
    v_product Products%ROWTYPE;
BEGIN
    LOOP
        FETCH p_cursor INTO v_product;
        EXIT WHEN p_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT

_LINE('Product ID: ' || v_product.ProductID || ', Name: ' || v_product.ProductName || ', Price: ' || v_product.Price);
    END LOOP;
    CLOSE p_cursor;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error displaying products: ' || SQLERRM);
END DisplayProducts;
```

**2.8. Bulk Collect**

```sql
-- Procedure using BULK COLLECT
CREATE OR REPLACE PROCEDURE BulkCollectProducts (
    p_category_name IN VARCHAR2
) AS
    TYPE ProductTable IS TABLE OF Products%ROWTYPE;
    v_products ProductTable;
BEGIN
    SELECT * BULK COLLECT INTO v_products
    FROM Products p
    JOIN ProductCategories pc ON p.ProductID = pc.ProductID
    JOIN Categories c ON pc.CategoryID = c.CategoryID
    WHERE c.CategoryName = p_category_name;
    
    FOR i IN 1..v_products.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Product ID: ' || v_products(i).ProductID || ', Name: ' || v_products(i).ProductName);
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error fetching products: ' || SQLERRM);
END BulkCollectProducts;
```

**2.9. Pipeline Functions**

```sql
-- Function to fetch products by category using pipelining
CREATE OR REPLACE FUNCTION PipelineProductsByCategory (
    p_category_name IN VARCHAR2
) RETURN SYS_REFCURSOR PIPELINED AS
BEGIN
    OPEN PIPELINE FOR
        SELECT p.ProductID, p.ProductName, p.Price
        FROM Products p
        JOIN ProductCategories pc ON p.ProductID = pc.ProductID
        JOIN Categories c ON pc.CategoryID = c.CategoryID
        WHERE c.CategoryName = p_category_name;
    RETURN;
END PipelineProductsByCategory;
```

**2.10. Dynamic SQL**

```sql
-- Procedure using Dynamic SQL to fetch products by dynamic condition
CREATE OR REPLACE PROCEDURE FetchProductsByCondition (
    p_condition IN VARCHAR2
) AS
    v_sql VARCHAR2(4000);
    v_cursor SYS_REFCURSOR;
BEGIN
    v_sql := 'SELECT ProductID, ProductName, Price FROM Products WHERE ' || p_condition;
    OPEN v_cursor FOR v_sql;
    
    -- Display products
    LOOP
        FETCH v_cursor INTO v_product;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Product ID: ' || v_product.ProductID || ', Name: ' || v_product.ProductName || ', Price: ' || v_product.Price);
    END LOOP;
    
    CLOSE v_cursor;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error executing dynamic SQL: ' || SQLERRM);
END FetchProductsByCondition;
```


**2.11. User-Defined Exceptions**

```sql
-- User-Defined Exception Definitions
CREATE OR REPLACE PACKAGE ErrorHandling AS
    insufficient_stock EXCEPTION;
    invalid_order EXCEPTION;
    no_product_found EXCEPTION;
    insufficient_stock_code NUMBER := -20001;
    invalid_order_code NUMBER := -20002;
    no_product_found_code NUMBER := -20003;
END ErrorHandling;
/

-- Package Body for Exception Handling
CREATE OR REPLACE PACKAGE BODY ErrorHandling AS

    PROCEDURE handle_exception(p_exception IN EXCEPTION) AS
    BEGIN
        IF p_exception = insufficient_stock THEN
            DBMS_OUTPUT.PUT_LINE('Insufficient stock error occurred.');
        ELSIF p_exception = invalid_order THEN
            DBMS_OUTPUT.PUT_LINE('Invalid order error occurred.');
        ELSIF p_exception = no_product_found THEN
            DBMS_OUTPUT.PUT_LINE('No product found error occurred.');
        ELSE
            DBMS_OUTPUT.PUT_LINE('An unknown error occurred.');
        END IF;
    END handle_exception;

END ErrorHandling;
/

-- Example Procedures Demonstrating User-Defined Exceptions
CREATE OR REPLACE PROCEDURE TestExceptionHandling (
    p_product_id IN NUMBER
) AS
    v_stock_quantity NUMBER;
BEGIN
    SELECT StockQuantity INTO v_stock_quantity FROM Products WHERE ProductID = p_product_id;
    
    IF v_stock_quantity < 1 THEN
        RAISE ErrorHandling.insufficient_stock;
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('Product stock is sufficient.');
EXCEPTION
    WHEN ErrorHandling.insufficient_stock THEN
        ErrorHandling.handle_exception(ErrorHandling.insufficient_stock);
    WHEN OTHERS THEN
        ErrorHandling.handle_exception(SQLCODE);
END TestExceptionHandling;
/

-- Use Cases for User-Defined Exceptions
BEGIN
    -- Case 1: Product with insufficient stock
    TestExceptionHandling(1001);
    
    -- Case 2: Product with sufficient stock
    TestExceptionHandling(1002);
END;
/

-- More procedures for different exception cases

-- Example 3: Handle invalid order exception
CREATE OR REPLACE PROCEDURE ValidateOrder (
    p_order_id IN NUMBER
) AS
BEGIN
    IF p_order_id <= 0 THEN
        RAISE ErrorHandling.invalid_order;
    END IF;
    DBMS_OUTPUT.PUT_LINE('Order ID is valid.');
EXCEPTION
    WHEN ErrorHandling.invalid_order THEN
        ErrorHandling.handle_exception(ErrorHandling.invalid_order);
END ValidateOrder;
/

-- Example 4: Handle no product found exception
CREATE OR REPLACE PROCEDURE FindProduct (
    p_product_id IN NUMBER
) AS
    v_product_name VARCHAR2(100);
BEGIN
    SELECT ProductName INTO v_product_name FROM Products WHERE ProductID = p_product_id;
    DBMS_OUTPUT.PUT_LINE('Product Name: ' || v_product_name);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE ErrorHandling.no_product_found;
    WHEN ErrorHandling.no_product_found THEN
        ErrorHandling.handle_exception(ErrorHandling.no_product_found);
END FindProduct;
/

-- Example 5: Handle exceptions in a function
CREATE OR REPLACE FUNCTION CalculateDiscount (
    p_price IN NUMBER,
    p_discount_percent IN NUMBER
) RETURN NUMBER AS
BEGIN
    RETURN p_price - (p_price * p_discount_percent / 100);
EXCEPTION
    WHEN VALUE_ERROR THEN
        RETURN 0;
    WHEN OTHERS THEN
        RETURN 0;
END CalculateDiscount;
/

-- Example 6: Use exception in bulk processing
CREATE OR REPLACE PROCEDURE ProcessOrdersBulk (
    p_order_ids IN SYS.ODCINUMBERLIST
) AS
BEGIN
    FOR i IN 1..p_order_ids.COUNT LOOP
        BEGIN
            -- Processing logic
            DBMS_OUTPUT.PUT_LINE('Processing Order ID: ' || p_order_ids(i));
        EXCEPTION
            WHEN OTHERS THEN
                ErrorHandling.handle_exception(SQLCODE);
        END;
    END LOOP;
END ProcessOrdersBulk;
/

-- Example 7: Exception in a dynamic SQL procedure
CREATE OR REPLACE PROCEDURE DynamicSQLExceptionHandling (
    p_table_name IN VARCHAR2
) AS
    v_sql VARCHAR2(1000);
BEGIN
    v_sql := 'SELECT * FROM ' || p_table_name;
    EXECUTE IMMEDIATE v_sql;
EXCEPTION
    WHEN OTHERS THEN
        ErrorHandling.handle_exception(SQLCODE);
END DynamicSQLExceptionHandling;
/

-- Example 8: Procedure with nested exceptions
CREATE OR REPLACE PROCEDURE NestedExceptionHandling (
    p_order_id IN NUMBER
) AS
BEGIN
    BEGIN
        -- Inner block
        IF p_order_id < 0 THEN
            RAISE ErrorHandling.invalid_order;
        END IF;
    EXCEPTION
        WHEN ErrorHandling.invalid_order THEN
            ErrorHandling.handle_exception(ErrorHandling.invalid_order);
            RAISE; -- Propagate exception to outer block
    END;
EXCEPTION
    WHEN OTHERS THEN
        ErrorHandling.handle_exception(SQLCODE);
END NestedExceptionHandling;
/

-- Example 9: Exception handling in a function with SQL error code
CREATE OR REPLACE FUNCTION HandleSQLExceptions (
    p_value IN NUMBER
) RETURN NUMBER AS
BEGIN
    RETURN p_value / 0; -- Causes divide by zero
EXCEPTION
    WHEN ZERO_DIVIDE THEN
        RETURN NULL;
    WHEN OTHERS THEN
        RETURN NULL;
END HandleSQLExceptions;
/

-- Example 10: Procedure to raise custom exceptions
CREATE OR REPLACE PROCEDURE RaiseCustomException (
    p_condition IN VARCHAR2
) AS
BEGIN
    IF p_condition = 'error1' THEN
        RAISE_APPLICATION_ERROR(ErrorHandling.insufficient_stock_code, 'Custom Error: Insufficient stock');
    ELSIF p_condition = 'error2' THEN
        RAISE_APPLICATION_ERROR(ErrorHandling.invalid_order_code, 'Custom Error: Invalid order');
    END IF;
END RaiseCustomException;
/
```

**2.12 Global Variable in a Package**

```sql
-- Package with a global variable
CREATE OR REPLACE PACKAGE GlobalVariables AS
    g_default_discount NUMBER := 10; -- Global variable for default discount
    PROCEDURE ApplyDiscount(p_product_id IN NUMBER);
    FUNCTION GetDiscountedPrice(p_product_id IN NUMBER) RETURN NUMBER;
END GlobalVariables;
/

-- Package body using the global variable
CREATE OR REPLACE PACKAGE BODY GlobalVariables AS

    PROCEDURE ApplyDiscount (
        p_product_id IN NUMBER
    ) AS
    BEGIN
        UPDATE Products
        SET Price = Price - (Price * g_default_discount / 100)
        WHERE ProductID = p_product_id;
        DBMS_OUTPUT.PUT_LINE('Discount applied to Product ID ' || p_product_id);
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Error applying discount: ' || SQLERRM);
    END ApplyDiscount;

    FUNCTION GetDiscountedPrice (
        p_product_id IN NUMBER
    ) RETURN NUMBER AS
        v_price NUMBER;
    BEGIN
        SELECT Price - (Price * g_default_discount / 100)
        INTO v_price
        FROM Products
        WHERE ProductID = p_product_id;
        RETURN v_price;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 0;
    WHEN OTHERS THEN
        RETURN 0;
    END GetDiscountedPrice;

END GlobalVariables;
/

-- Example Uses of Global Variable

-- Example 1: Apply discount using global variable
BEGIN
    GlobalVariables.ApplyDiscount(1001);
END;
/

-- Example 2: Get discounted price using global variable
DECLARE
    v_price NUMBER;
BEGIN
    v_price := GlobalVariables.GetDiscountedPrice(1001);
    DBMS_OUTPUT.PUT_LINE('Discounted Price: ' || v_price);
END;
/

-- Example 3: Update global discount value
BEGIN
    GlobalVariables.g_default_discount := 20;
    GlobalVariables.ApplyDiscount(1002);
END;
/

-- Example 4: Verify new discounted price
DECLARE
    v_price NUMBER;
BEGIN
    v_price := GlobalVariables.GetDiscountedPrice(1002);
    DBMS_OUTPUT.PUT_LINE('Discounted Price after update: ' || v_price);
END;
/

-- Example 5: Apply discount to multiple products
BEGIN
    FOR i IN 1003..1005 LOOP
        GlobalVariables.ApplyDiscount(i);
    END LOOP;
END;
/

-- Example 6: Check price for products with applied discount
DECLARE
    v_price NUMBER;
BEGIN
    FOR i IN 1003..1005 LOOP
        v_price := GlobalVariables.GetDiscountedPrice(i);
        DBMS_OUTPUT.PUT_LINE('Product ID ' || i || ' Discounted Price: ' || v_price);
    END LOOP;
END;
/

-- Example 7: Test default discount variable
BEGIN
    DBMS_OUTPUT.PUT_LINE('Default Discount: ' || GlobalVariables.g_default_discount);
END;
/

-- Example 8: Modify discount and apply
BEGIN
    GlobalVariables.g_default_discount := 15;
    GlobalVariables.ApplyDiscount(1006);
END;
/

-- Example 9: Calculate price for specific product
DECLARE
    v_price NUMBER;
BEGIN
    v_price := GlobalVariables.GetDiscountedPrice(1006);
    DBMS_OUTPUT.PUT_LINE('Discounted Price: ' || v_price);
END;
/

-- Example 10: Reset default discount
BEGIN
    GlobalVariables.g_default_discount := 10;
END;
/
```

**2.13. Procedure and Function Overloading in Packages**

```sql
-- Package with overloaded procedures and functions
CREATE OR REPLACE PACKAGE OrderPackage AS
    PROCEDURE PlaceOrder(p_customer_id IN NUMBER, p_total_amount IN NUMBER);
    PROCEDURE PlaceOrder(p_customer_id IN NUMBER, p

_order_date IN DATE, p_total_amount IN NUMBER);
    FUNCTION CalculateDiscount(p_order_id IN NUMBER) RETURN NUMBER;
    FUNCTION CalculateDiscount(p_order_id IN NUMBER, p_discount_rate IN NUMBER) RETURN NUMBER;
END OrderPackage;
/

-- Package body with overloaded procedures and functions
CREATE OR REPLACE PACKAGE BODY OrderPackage AS

    PROCEDURE PlaceOrder (
        p_customer_id IN NUMBER,
        p_total_amount IN NUMBER
    ) AS
    BEGIN
        INSERT INTO Orders (CustomerID, OrderDate, TotalAmount)
        VALUES (p_customer_id, SYSDATE, p_total_amount);
        DBMS_OUTPUT.PUT_LINE('Order placed with total amount: ' || p_total_amount);
    END PlaceOrder;

    PROCEDURE PlaceOrder (
        p_customer_id IN NUMBER,
        p_order_date IN DATE,
        p_total_amount IN NUMBER
    ) AS
    BEGIN
        INSERT INTO Orders (CustomerID, OrderDate, TotalAmount)
        VALUES (p_customer_id, p_order_date, p_total_amount);
        DBMS_OUTPUT.PUT_LINE('Order placed on ' || p_order_date || ' with total amount: ' || p_total_amount);
    END PlaceOrder;

    FUNCTION CalculateDiscount (
        p_order_id IN NUMBER
    ) RETURN NUMBER AS
        v_discount NUMBER := 10;
    BEGIN
        -- Return default discount
        RETURN v_discount;
    END CalculateDiscount;

    FUNCTION CalculateDiscount (
        p_order_id IN NUMBER,
        p_discount_rate IN NUMBER
    ) RETURN NUMBER AS
        v_discount NUMBER;
    BEGIN
        -- Return discount based on rate
        v_discount := p_discount_rate;
        RETURN v_discount;
    END CalculateDiscount;

END OrderPackage;
/

-- Example Uses for Overloaded Procedures and Functions

-- Example 1: Place order with total amount only
BEGIN
    OrderPackage.PlaceOrder(101, 500);
END;
/

-- Example 2: Place order with specific date and total amount
BEGIN
    OrderPackage.PlaceOrder(102, DATE '2024-08-15', 700);
END;
/

-- Example 3: Calculate default discount
DECLARE
    v_discount NUMBER;
BEGIN
    v_discount := OrderPackage.CalculateDiscount(1001);
    DBMS_OUTPUT.PUT_LINE('Default Discount: ' || v_discount);
END;
/

-- Example 4: Calculate discount with custom rate
DECLARE
    v_discount NUMBER;
BEGIN
    v_discount := OrderPackage.CalculateDiscount(1002, 20);
    DBMS_OUTPUT.PUT_LINE('Custom Discount: ' || v_discount);
END;
/

-- Example 5: Use overloaded procedure with different parameters
BEGIN
    OrderPackage.PlaceOrder(103, SYSDATE, 1200);
END;
/

-- Example 6: Call overloaded function with different parameters
DECLARE
    v_discount NUMBER;
BEGIN
    v_discount := OrderPackage.CalculateDiscount(1003);
    DBMS_OUTPUT.PUT_LINE('Discount: ' || v_discount);
    v_discount := OrderPackage.CalculateDiscount(1004, 15);
    DBMS_OUTPUT.PUT_LINE('Discount with custom rate: ' || v_discount);
END;
/

-- Example 7: Place order without specifying date
BEGIN
    OrderPackage.PlaceOrder(104, 1500);
END;
/

-- Example 8: Place order with a specified date
BEGIN
    OrderPackage.PlaceOrder(105, DATE '2024-09-01', 1800);
END;
/

-- Example 9: Calculate discount for a specific order with default rate
DECLARE
    v_discount NUMBER;
BEGIN
    v_discount := OrderPackage.CalculateDiscount(1005);
    DBMS_OUTPUT.PUT_LINE('Calculated Discount: ' || v_discount);
END;
/

-- Example 10: Calculate discount for a specific order with a custom rate
DECLARE
    v_discount NUMBER;
BEGIN
    v_discount := OrderPackage.CalculateDiscount(1006, 25);
    DBMS_OUTPUT.PUT_LINE('Calculated Discount with custom rate: ' || v_discount);
END;
/
```

**2.14. Triggers**

```sql
-- Create tables
CREATE TABLE Products (
    ProductID NUMBER PRIMARY KEY,
    ProductName VARCHAR2(100),
    Price NUMBER,
    StockQuantity NUMBER
);

CREATE TABLE Orders (
    OrderID NUMBER PRIMARY KEY,
    CustomerID NUMBER,
    OrderDate DATE,
    TotalAmount NUMBER
);

-- Trigger to update stock quantity after order insertion
CREATE OR REPLACE TRIGGER UpdateStockAfterOrder
AFTER INSERT ON Orders
FOR EACH ROW
BEGIN
    UPDATE Products
    SET StockQuantity = StockQuantity - 1
    WHERE ProductID = :NEW.ProductID;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error updating stock: ' || SQLERRM);
END;
/

-- Trigger to log deletions in a separate table
CREATE TABLE DeletedOrdersLog (
    OrderID NUMBER,
    DeletedAt DATE
);

CREATE OR REPLACE TRIGGER LogOrderDeletion
AFTER DELETE ON Orders
FOR EACH ROW
BEGIN
    INSERT INTO DeletedOrdersLog (OrderID, DeletedAt)
    VALUES (:OLD.OrderID, SYSDATE);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error logging deletion: ' || SQLERRM);
END;
/

-- Trigger to set default values before insertion
CREATE OR REPLACE TRIGGER SetDefaultOrderValues
BEFORE INSERT ON Orders
FOR EACH ROW
BEGIN
    IF :NEW.OrderDate IS NULL THEN
        :NEW.OrderDate := SYSDATE;
    END IF;
    IF :NEW.TotalAmount IS NULL THEN
        :NEW.TotalAmount := 0;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error setting default values: ' || SQLERRM);
END;
/

-- Trigger to prevent negative stock quantity
CREATE OR REPLACE TRIGGER PreventNegativeStock
BEFORE UPDATE ON Products
FOR EACH ROW
BEGIN
    IF :NEW.StockQuantity < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Stock quantity cannot be negative.');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error preventing negative stock: ' || SQLERRM);
END;
/

-- Trigger to automatically update order total before insertion
CREATE OR REPLACE TRIGGER UpdateOrderTotal
BEFORE INSERT ON Orders
FOR EACH ROW
BEGIN
    SELECT SUM(Price) INTO :NEW.TotalAmount
    FROM OrderDetails
    WHERE OrderID = :NEW.OrderID;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error updating order total: ' || SQLERRM);
END;
/

-- Example triggers with logging

-- Example 1: Log order creation
CREATE OR REPLACE TRIGGER LogOrderCreation
AFTER INSERT ON Orders
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('Order Created: ' || :NEW.OrderID);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error logging order creation: ' || SQLERRM);
END;
/

-- Example 2: Log order updates
CREATE OR REPLACE TRIGGER LogOrderUpdate
AFTER UPDATE ON Orders
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('Order Updated: ' || :NEW.OrderID);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error logging order update: ' || SQLERRM);
END;
/

-- Example 3: Log product price changes
CREATE OR REPLACE TRIGGER LogProductPriceChange
AFTER UPDATE ON Products
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('Product Price Changed: ' || :NEW.ProductID || ' New Price: ' || :NEW.Price);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error logging product price change: ' || SQLERRM);
END;
/

-- Example 4: Check stock levels before insert
CREATE OR REPLACE TRIGGER CheckStockBeforeInsert
BEFORE INSERT ON Orders
FOR EACH ROW
BEGIN
    DECLARE
        v_stock_quantity NUMBER;
    BEGIN
        SELECT StockQuantity INTO v_stock_quantity FROM Products WHERE ProductID = :NEW.ProductID;
        IF v_stock_quantity < 1 THEN
            RAISE_APPLICATION_ERROR(-20002, 'Insufficient stock for Product ID ' || :NEW.ProductID);
        END IF;
    END;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error checking stock before order insert: ' || SQLERRM);
END;
/

-- Example 5: Auto-generate order IDs
CREATE OR REPLACE TRIGGER GenerateOrderID
BEFORE INSERT ON Orders
FOR EACH ROW
BEGIN
    SELECT order_id_seq.NEXTVAL INTO :NEW.OrderID FROM dual;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error generating order ID: ' || SQLERRM);
END;
/

-- Example 6: Log changes in order status
CREATE OR REPLACE TRIGGER LogOrderStatusChange
AFTER UPDATE ON Orders
FOR EACH ROW
BEGIN
    IF :OLD.Status <> :NEW.Status THEN
        DBMS_OUTPUT.PUT_LINE('Order Status Changed: ' || :NEW.OrderID || ' Old Status: ' || :OLD.Status || ' New Status: ' || :NEW.Status);
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error logging order status change: ' || SQLERRM);
END;
/

-- Example 7: Calculate and update discount before insert
CREATE OR REPLACE TRIGGER CalculateDiscountBeforeInsert
BEFORE INSERT ON Orders
FOR EACH ROW
BEGIN
    :NEW.TotalAmount := :NEW.TotalAmount - (:NEW.TotalAmount * 0.1);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT

.PUT_LINE('Error calculating discount before order insert: ' || SQLERRM);
END;
/

-- Example 8: Prevent duplicate order entries
CREATE OR REPLACE TRIGGER PreventDuplicateOrders
BEFORE INSERT ON Orders
FOR EACH ROW
BEGIN
    IF EXISTS (SELECT 1 FROM Orders WHERE OrderID = :NEW.OrderID) THEN
        RAISE_APPLICATION_ERROR(-20003, 'Order ID ' || :NEW.OrderID || ' already exists.');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error preventing duplicate orders: ' || SQLERRM);
END;
/

-- Example 9: Validate order date before insert
CREATE OR REPLACE TRIGGER ValidateOrderDate
BEFORE INSERT ON Orders
FOR EACH ROW
BEGIN
    IF :NEW.OrderDate < SYSDATE THEN
        RAISE_APPLICATION_ERROR(-20004, 'Order date cannot be in the past.');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error validating order date: ' || SQLERRM);
END;
/

-- Example 10: Log product deletion
CREATE OR REPLACE TRIGGER LogProductDeletion
AFTER DELETE ON Products
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('Product Deleted: ' || :OLD.ProductID || ' Product Name: ' || :OLD.ProductName);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error logging product deletion: ' || SQLERRM);
END;
/
```

**2.15. Collections**

```sql
-- Define a package with collection types
CREATE OR REPLACE PACKAGE CollectionExamples AS
    TYPE NumList IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    TYPE EmpRec IS RECORD (
        emp_id NUMBER,
        emp_name VARCHAR2(100)
    );
    TYPE EmpList IS TABLE OF EmpRec INDEX BY PLS_INTEGER;

    PROCEDURE ProcessNumbers;
    PROCEDURE ProcessEmployees;
END CollectionExamples;
/

-- Package body with procedures using collections
CREATE OR REPLACE PACKAGE BODY CollectionExamples AS

    PROCEDURE ProcessNumbers AS
        v_numbers NumList;
        v_count PLS_INTEGER;
    BEGIN
        v_numbers(1) := 10;
        v_numbers(2) := 20;
        v_numbers(3) := 30;

        FOR i IN v_numbers.FIRST..v_numbers.LAST LOOP
            DBMS_OUTPUT.PUT_LINE('Number: ' || v_numbers(i));
        END LOOP;
    END ProcessNumbers;

    PROCEDURE ProcessEmployees AS
        v_employees EmpList;
        v_count PLS_INTEGER;
    BEGIN
        v_employees(1).emp_id := 101;
        v_employees(1).emp_name := 'John Doe';
        
        v_employees(2).emp_id := 102;
        v_employees(2).emp_name := 'Jane Smith';

        FOR i IN v_employees.FIRST..v_employees.LAST LOOP
            DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_employees(i).emp_id || ' Name: ' || v_employees(i).emp_name);
        END LOOP;
    END ProcessEmployees;

END CollectionExamples;
/

-- Example Uses of Collections

-- Example 1: Process numbers collection
BEGIN
    CollectionExamples.ProcessNumbers;
END;
/

-- Example 2: Process employees collection
BEGIN
    CollectionExamples.ProcessEmployees;
END;
/

-- Example 3: Use collection in a loop
DECLARE
    TYPE NumArray IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    nums NumArray;
BEGIN
    nums(1) := 100;
    nums(2) := 200;
    nums(3) := 300;

    FOR i IN nums.FIRST..nums.LAST LOOP
        DBMS_OUTPUT.PUT_LINE('Num: ' || nums(i));
    END LOOP;
END;
/

-- Example 4: Use record in a collection
DECLARE
    TYPE EmpRec IS RECORD (
        emp_id NUMBER,
        emp_name VARCHAR2(100)
    );
    TYPE EmpArray IS TABLE OF EmpRec INDEX BY PLS_INTEGER;
    employees EmpArray;
BEGIN
    employees(1).emp_id := 201;
    employees(1).emp_name := 'Alice Brown';
    
    employees(2).emp_id := 202;
    employees(2).emp_name := 'Bob Green';

    FOR i IN employees.FIRST..employees.LAST LOOP
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || employees(i).emp_id || ' Name: ' || employees(i).emp_name);
    END LOOP;
END;
/

-- Example 5: Populate collection from a query
DECLARE
    TYPE DeptList IS TABLE OF VARCHAR2(100) INDEX BY PLS_INTEGER;
    departments DeptList;
    i PLS_INTEGER;
BEGIN
    FOR i IN 1..5 LOOP
        departments(i) := 'Dept' || i;
    END LOOP;

    FOR i IN departments.FIRST..departments.LAST LOOP
        DBMS_OUTPUT.PUT_LINE('Department: ' || departments(i));
    END LOOP;
END;
/

-- Example 6: Use collection in PL/SQL table
DECLARE
    TYPE NumTable IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    nums NumTable;
BEGIN
    nums(1) := 1;
    nums(2) := 2;
    nums(3) := 3;

    FOR i IN nums.FIRST..nums.LAST LOOP
        DBMS_OUTPUT.PUT_LINE('Number: ' || nums(i));
    END LOOP;
END;
/

-- Example 7: Use collection to aggregate values
DECLARE
    TYPE SalaryList IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    salaries SalaryList;
    total_salary NUMBER := 0;
BEGIN
    salaries(1) := 5000;
    salaries(2) := 6000;
    salaries(3) := 7000;

    FOR i IN salaries.FIRST..salaries.LAST LOOP
        total_salary := total_salary + salaries(i);
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('Total Salary: ' || total_salary);
END;
/

-- Example 8: Use associative array for dynamic data
DECLARE
    TYPE NameArray IS TABLE OF VARCHAR2(100) INDEX BY VARCHAR2(100);
    names NameArray;
BEGIN
    names('John') := 'Doe';
    names('Jane') := 'Smith';

    DBMS_OUTPUT.PUT_LINE('John\'s Last Name: ' || names('John'));
    DBMS_OUTPUT.PUT_LINE('Jane\'s Last Name: ' || names('Jane'));
END;
/

-- Example 9: Using record type in a procedure
CREATE OR REPLACE PROCEDURE ShowEmployeeInfo (
    p_emp_id IN NUMBER
) AS
    TYPE EmpRecord IS RECORD (
        emp_id NUMBER,
        emp_name VARCHAR2(100),
        emp_salary NUMBER
    );
    v_emp EmpRecord;
BEGIN
    SELECT EmployeeID, EmployeeName, Salary INTO v_emp
    FROM Employees
    WHERE EmployeeID = p_emp_id;
    
    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_emp.emp_id);
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_emp.emp_name);
    DBMS_OUTPUT.PUT_LINE('Employee Salary: ' || v_emp.emp_salary);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error retrieving employee info: ' || SQLERRM);
END ShowEmployeeInfo;
/

-- Example 10: Use PL/SQL table with INSERT statement
DECLARE
    TYPE ProductList IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    product_ids ProductList;
BEGIN
    product_ids(1) := 301;
    product_ids(2) := 302;
    product_ids(3) := 303;

    FOR i IN product_ids.FIRST..product_ids.LAST LOOP
        INSERT INTO ProductLogs (ProductID, LogDate)
        VALUES (product_ids(i), SYSDATE);
    END LOOP;
END;
/
```

**2.16. REF CURSOR**

```sql
-- Define a package with REF CURSOR
CREATE OR REPLACE PACKAGE RefCursorPackage AS
    TYPE ref_cursor IS REF CURSOR;
    PROCEDURE GetEmployees(p_cursor OUT ref_cursor);
    FUNCTION GetEmployeeName(p_emp_id IN NUMBER) RETURN VARCHAR2;
END RefCursorPackage;
/

-- Package body for REF CURSOR
CREATE OR REPLACE PACKAGE BODY RefCursorPackage AS

    PROCEDURE GetEmployees (
        p_cursor OUT ref_cursor
    ) AS
    BEGIN
        OPEN p_cursor FOR
            SELECT EmployeeID, EmployeeName
            FROM Employees;
    END GetEmployees;

    FUNCTION GetEmployeeName (
        p_emp_id IN NUMBER
    ) RETURN VARCHAR2 AS
        v_name VARCHAR2(100);
    BEGIN
        SELECT EmployeeName INTO v_name
        FROM Employees
        WHERE EmployeeID = p_emp_id;
        RETURN v_name;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 'Not Found';
    END GetEmployeeName;

END RefCursorPackage;
/

-- Example Uses of REF CURSOR

-- Example 1: Fetch employee data using REF CURSOR
DECLARE
    v_cursor RefCursorPackage.ref_cursor;
    v_emp_id Employees.EmployeeID%TYPE;
    v_emp_name Employees.EmployeeName%TYPE;
BEGIN
    RefCursorPackage.GetEmployees(v_cursor);

    LOOP
        FETCH v_cursor INTO v_emp_id, v_emp_name;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_emp_id || ' Name: ' || v_emp_name);
    END LOOP;

    CLOSE v_cursor;
END;
/

-- Example 2: Get employee name function
DECLARE
    v_name VARCHAR2(100);
BEGIN
    v_name := RefCursorPackage

.GetEmployeeName(1001);
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name);
END;
/

-- Example 3: Fetch employee names in a cursor
DECLARE
    v_cursor RefCursorPackage.ref_cursor;
    v_emp_name Employees.EmployeeName%TYPE;
BEGIN
    RefCursorPackage.GetEmployees(v_cursor);

    LOOP
        FETCH v_cursor INTO v_emp_name;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_emp_name);
    END LOOP;

    CLOSE v_cursor;
END;
/

-- Example 4: Use REF CURSOR with a parameterized query
DECLARE
    TYPE emp_cursor IS REF CURSOR;
    v_cursor emp_cursor;
    v_emp_id Employees.EmployeeID%TYPE := 1002;
    v_emp_name Employees.EmployeeName%TYPE;
BEGIN
    OPEN v_cursor FOR
        SELECT EmployeeName
        FROM Employees
        WHERE EmployeeID = v_emp_id;

    FETCH v_cursor INTO v_emp_name;
    DBMS_OUTPUT.PUT_LINE('Employee Name for ID ' || v_emp_id || ': ' || v_emp_name);

    CLOSE v_cursor;
END;
/

-- Example 5: Handle no data found using REF CURSOR
DECLARE
    v_cursor RefCursorPackage.ref_cursor;
    v_emp_name Employees.EmployeeName%TYPE;
BEGIN
    RefCursorPackage.GetEmployees(v_cursor);

    LOOP
        FETCH v_cursor INTO v_emp_name;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_emp_name);
    END LOOP;

    CLOSE v_cursor;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No employees found.');
END;
/

-- Example 6: Use REF CURSOR to fetch data from different tables
DECLARE
    v_cursor RefCursorPackage.ref_cursor;
    v_emp_id Employees.EmployeeID%TYPE;
    v_emp_name Employees.EmployeeName%TYPE;
BEGIN
    OPEN v_cursor FOR
        SELECT e.EmployeeID, e.EmployeeName
        FROM Employees e
        JOIN Departments d ON e.DepartmentID = d.DepartmentID
        WHERE d.DepartmentName = 'IT';

    LOOP
        FETCH v_cursor INTO v_emp_id, v_emp_name;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_emp_id || ' Name: ' || v_emp_name);
    END LOOP;

    CLOSE v_cursor;
END;
/

-- Example 7: Fetch data from a REF CURSOR in a function
DECLARE
    v_cursor RefCursorPackage.ref_cursor;
    v_emp_id Employees.EmployeeID%TYPE;
    v_emp_name Employees.EmployeeName%TYPE;
BEGIN
    RefCursorPackage.GetEmployees(v_cursor);

    LOOP
        FETCH v_cursor INTO v_emp_id, v_emp_name;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_emp_id || ' Name: ' || v_emp_name);
    END LOOP;

    CLOSE v_cursor;
END;
/

-- Example 8: Use REF CURSOR for dynamic SQL
DECLARE
    v_cursor RefCursorPackage.ref_cursor;
    v_sql VARCHAR2(4000);
    v_emp_id Employees.EmployeeID%TYPE;
    v_emp_name Employees.EmployeeName%TYPE;
BEGIN
    v_sql := 'SELECT EmployeeID, EmployeeName FROM Employees';

    OPEN v_cursor FOR v_sql;

    LOOP
        FETCH v_cursor INTO v_emp_id, v_emp_name;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_emp_id || ' Name: ' || v_emp_name);
    END LOOP;

    CLOSE v_cursor;
END;
/

-- Example 9: Get employee names with error handling
DECLARE
    v_cursor RefCursorPackage.ref_cursor;
    v_emp_name Employees.EmployeeName%TYPE;
BEGIN
    RefCursorPackage.GetEmployees(v_cursor);

    LOOP
        FETCH v_cursor INTO v_emp_name;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_emp_name);
    END LOOP;

    CLOSE v_cursor;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error fetching employee data: ' || SQLERRM);
END;
/

-- Example 10: Using REF CURSOR to paginate results
DECLARE
    v_cursor RefCursorPackage.ref_cursor;
    v_emp_id Employees.EmployeeID%TYPE;
    v_emp_name Employees.EmployeeName%TYPE;
    v_limit NUMBER := 10;
    v_offset NUMBER := 0;
BEGIN
    OPEN v_cursor FOR
        SELECT EmployeeID, EmployeeName
        FROM (SELECT EmployeeID, EmployeeName, ROW_NUMBER() OVER (ORDER BY EmployeeID) AS rownum
              FROM Employees)
        WHERE rownum > v_offset AND rownum <= (v_offset + v_limit);

    LOOP
        FETCH v_cursor INTO v_emp_id, v_emp_name;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || v_emp_id || ' Name: ' || v_emp_name);
    END LOOP;

    CLOSE v_cursor;
END;
/
```
