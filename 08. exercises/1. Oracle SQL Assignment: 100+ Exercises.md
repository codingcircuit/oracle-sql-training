# Oracle SQL Assignment: 100+ Exercises

## Index

1. [DDL Exercises](#1-ddl-exercises)
   - [Creating Tables](#creating-tables)
   - [Altering Tables](#altering-tables)
   - [Dropping Tables](#dropping-tables)
   - [Creating Indexes](#creating-indexes)
   - [Dropping Indexes](#dropping-indexes)
   - [Creating Views](#creating-views)
   - [Dropping Views](#dropping-views)
   - [Creating Sequences](#creating-sequences)
   - [Dropping Sequences](#dropping-sequences)
   - [Creating Synonyms](#creating-synonyms)
   - [Dropping Synonyms](#dropping-synonyms)

2. [DML Exercises](#2-dml-exercises)
   - [Inserting Data](#inserting-data)
   - [Updating Data](#updating-data)
   - [Deleting Data](#deleting-data)
   - [Selecting Data](#selecting-data)
   - [Using Joins](#using-joins)
   - [Using Subqueries](#using-subqueries)
   - [Using Aggregate Functions](#using-aggregate-functions)
   - [Using Group By](#using-group-by)
   - [Using Order By](#using-order-by)
   - [Using Union and Union All](#using-union-and-union-all)

3. [Advanced SQL Exercises](#3-advanced-sql-exercises)
   - [Using Analytical Functions](#using-analytical-functions)
   - [Using Common Table Expressions (CTEs)](#using-common-table-expressions-ctes)
   - [Using Case Statements](#using-case-statements)
   - [Using Window Functions](#using-window-functions)
   - [Using PIVOT and UNPIVOT](#using-pivot-and-unpivot)
   - [Creating and Using Materialized Views](#creating-and-using-materialized-views)
   - [Creating and Using Triggers](#creating-and-using-triggers)
   - [Creating and Using Stored Procedures](#creating-and-using-stored-procedures)
   - [Creating and Using Functions](#creating-and-using-functions)
   - [Using Dynamic SQL](#using-dynamic-sql)

4. [Additional Exercises](#4-additional-exercises)
   - [Nested Queries](#nested-queries)
   - [Advanced Joins](#advanced-joins)
   - [Regular Expressions](#regular-expressions)
   - [Hierarchical Queries](#hierarchical-queries)
   - [SQL Performance Tuning](#sql-performance-tuning)

---

## 1. DDL Exercises

### Creating Tables

**Exercise 1:** Create a table named `employees` with columns for `employee_id`, `first_name`, `last_name`, `hire_date`, and `salary`.

```sql
CREATE TABLE employees (
  employee_id NUMBER PRIMARY KEY,
  first_name VARCHAR2(50),
  last_name VARCHAR2(50),
  hire_date DATE,
  salary NUMBER(8, 2)
);
```

**Exercise 2:** Create a table named `departments` with columns for `department_id`, `department_name`, and `location`.

```sql
CREATE TABLE departments (
  department_id NUMBER PRIMARY KEY,
  department_name VARCHAR2(50),
  location VARCHAR2(100)
);
```

**Exercise 3:** Create a table named `projects` with columns for `project_id`, `project_name`, `start_date`, and `end_date`.

```sql
CREATE TABLE projects (
  project_id NUMBER PRIMARY KEY,
  project_name VARCHAR2(100),
  start_date DATE,
  end_date DATE
);
```

**Exercise 4:** Create a table named `employee_projects` with columns for `employee_id`, `project_id`, and `hours_worked`. 

```sql
CREATE TABLE employee_projects (
  employee_id NUMBER,
  project_id NUMBER,
  hours_worked NUMBER,
  CONSTRAINT pk_employee_projects PRIMARY KEY (employee_id, project_id),
  CONSTRAINT fk_employee FOREIGN KEY (employee_id) REFERENCES employees(employee_id),
  CONSTRAINT fk_project FOREIGN KEY (project_id) REFERENCES projects(project_id)
);
```

### Altering Tables

**Exercise 5:** Add a new column `email` to the `employees` table.

```sql
ALTER TABLE employees ADD email VARCHAR2(100);
```

**Exercise 6:** Modify the `salary` column in the `employees` table to allow up to 10 digits with 2 decimal places.

```sql
ALTER TABLE employees MODIFY salary NUMBER(10, 2);
```

**Exercise 7:** Rename the `departments` table to `dept`.

```sql
ALTER TABLE departments RENAME TO dept;
```

**Exercise 8:** Add a new column `project_manager` to the `projects` table.

```sql
ALTER TABLE projects ADD project_manager VARCHAR2(100);
```

**Exercise 9:** Change the data type of the `hours_worked` column in the `employee_projects` table to `NUMBER(5, 2)`.

```sql
ALTER TABLE employee_projects MODIFY hours_worked NUMBER(5, 2);
```

### Dropping Tables

**Exercise 10:** Drop the `employees` table.

```sql
DROP TABLE employees;
```

**Exercise 11:** Drop the `dept` table.

```sql
DROP TABLE dept;
```

**Exercise 12:** Drop the `projects` table.

```sql
DROP TABLE projects;
```

**Exercise 13:** Drop the `employee_projects` table.

```sql
DROP TABLE employee_projects;
```

### Creating Indexes

**Exercise 14:** Create an index on the `last_name` column of the `employees` table.

```sql
CREATE INDEX idx_last_name ON employees (last_name);
```

**Exercise 15:** Create a unique index on the `email` column of the `employees` table.

```sql
CREATE UNIQUE INDEX idx_email ON employees (email);
```

**Exercise 16:** Create an index on the `project_name` column of the `projects` table.

```sql
CREATE INDEX idx_project_name ON projects (project_name);
```

**Exercise 17:** Create a composite index on the `employee_id` and `project_id` columns of the `employee_projects` table.

```sql
CREATE INDEX idx_employee_project ON employee_projects (employee_id, project_id);
```

### Dropping Indexes

**Exercise 18:** Drop the index `idx_last_name`.

```sql
DROP INDEX idx_last_name;
```

**Exercise 19:** Drop the unique index `idx_email`.

```sql
DROP INDEX idx_email;
```

**Exercise 20:** Drop the index `idx_project_name`.

```sql
DROP INDEX idx_project_name;
```

**Exercise 21:** Drop the composite index `idx_employee_project`.

```sql
DROP INDEX idx_employee_project;
```

### Creating Views

**Exercise 22:** Create a view named `employee_view` that shows the `employee_id`, `first_name`, and `salary` from the `employees` table.

```sql
CREATE VIEW employee_view AS
SELECT employee_id, first_name, salary
FROM employees;
```

**Exercise 23:** Create a view named `department_view` to show the `department_name` and `location` from the `dept` table.

```sql
CREATE VIEW department_view AS
SELECT department_name, location
FROM dept;
```

**Exercise 24:** Create a view `project_summary` that shows the `project_name` and the number of employees assigned to each project.

```sql
CREATE VIEW project_summary AS
SELECT p.project_name, COUNT(ep.employee_id) AS num_employees
FROM projects p
LEFT JOIN employee_projects ep ON p.project_id = ep.project_id
GROUP BY p.project_name;
```

### Dropping Views

**Exercise 25:** Drop the `employee_view` view.

```sql
DROP VIEW employee_view;
```

**Exercise 26:** Drop the `department_view` view.

```sql
DROP VIEW department_view;
```

**Exercise 27:** Drop the `project_summary` view.

```sql
DROP VIEW project_summary;
```

### Creating Sequences

**Exercise 28:** Create a sequence named `employee_seq` that starts at 1 and increments by 1.

```sql
CREATE SEQUENCE employee_seq
START WITH 1
INCREMENT BY 1;
```

**Exercise 29:** Create a sequence named `dept_seq` that starts at 100 and increments by 10.

```sql
CREATE SEQUENCE dept_seq
START WITH 100
INCREMENT BY 10;
```

**Exercise 30:** Create a sequence named `project_seq` with a starting value of 500 and incrementing by 5.

```sql
CREATE SEQUENCE project_seq
START WITH 500
INCREMENT BY 5;
```

### Dropping Sequences

**Exercise 31:** Drop the sequence `employee_seq`.

```sql
DROP SEQUENCE employee_seq;
```

**Exercise 32:** Drop the sequence `dept_seq`.

```sql
DROP SEQUENCE dept_seq;
```

**Exercise 33:** Drop the sequence `project_seq`.

```sql
DROP SEQUENCE project_seq;
```

### Creating Synonyms

**Exercise 34:** Create a synonym `emp_synonym` for the `employees` table.

```sql
CREATE SYNONYM emp_synonym FOR employees;
```

**Exercise 35:** Create a synonym `dept_synonym` for the `dept` table.

```sql
CREATE SYNONYM dept_synonym FOR dept;
```

**Exercise 36:** Create a synonym `proj_synonym`

 for the `projects` table.

```sql
CREATE SYNONYM proj_synonym FOR projects;
```

### Dropping Synonyms

**Exercise 37:** Drop the synonym `emp_synonym`.

```sql
DROP SYNONYM emp_synonym;
```

**Exercise 38:** Drop the synonym `dept_synonym`.

```sql
DROP SYNONYM dept_synonym;
```

**Exercise 39:** Drop the synonym `proj_synonym`.

```sql
DROP SYNONYM proj_synonym;
```

---

## 2. DML Exercises

### Inserting Data

**Exercise 40:** Insert a record into the `employees` table.

```sql
INSERT INTO employees (employee_id, first_name, last_name, hire_date, salary)
VALUES (1, 'John', 'Doe', TO_DATE('2022-01-15', 'YYYY-MM-DD'), 50000);
```

**Exercise 41:** Insert multiple records into the `departments` table.

```sql
INSERT INTO departments (department_id, department_name, location)
VALUES (1, 'HR', 'New York'),
       (2, 'IT', 'San Francisco'),
       (3, 'Finance', 'Chicago');
```

**Exercise 42:** Insert data into the `projects` table.

```sql
INSERT INTO projects (project_id, project_name, start_date, end_date)
VALUES (1, 'Project Alpha', TO_DATE('2023-03-01', 'YYYY-MM-DD'), TO_DATE('2023-09-30', 'YYYY-MM-DD'));
```

**Exercise 43:** Insert data into the `employee_projects` table.

```sql
INSERT INTO employee_projects (employee_id, project_id, hours_worked)
VALUES (1, 1, 120);
```

### Updating Data

**Exercise 44:** Update the salary of an employee with `employee_id` 1.

```sql
UPDATE employees
SET salary = 55000
WHERE employee_id = 1;
```

**Exercise 45:** Update the `location` of the `IT` department to `Los Angeles`.

```sql
UPDATE departments
SET location = 'Los Angeles'
WHERE department_name = 'IT';
```

**Exercise 46:** Update the `end_date` of `Project Alpha`.

```sql
UPDATE projects
SET end_date = TO_DATE('2023-12-31', 'YYYY-MM-DD')
WHERE project_name = 'Project Alpha';
```

**Exercise 47:** Update the `hours_worked` for an employee in a project.

```sql
UPDATE employee_projects
SET hours_worked = 150
WHERE employee_id = 1 AND project_id = 1;
```

### Deleting Data

**Exercise 48:** Delete an employee with `employee_id` 1.

```sql
DELETE FROM employees
WHERE employee_id = 1;
```

**Exercise 49:** Delete all records from the `departments` table.

```sql
DELETE FROM departments;
```

**Exercise 50:** Delete a project with `project_id` 1.

```sql
DELETE FROM projects
WHERE project_id = 1;
```

**Exercise 51:** Delete all records from the `employee_projects` table where `hours_worked` is less than 100.

```sql
DELETE FROM employee_projects
WHERE hours_worked < 100;
```

### Selecting Data

**Exercise 52:** Select all columns from the `employees` table.

```sql
SELECT * FROM employees;
```

**Exercise 53:** Select `first_name` and `salary` from the `employees` table.

```sql
SELECT first_name, salary
FROM employees;
```

**Exercise 54:** Select distinct `location` from the `departments` table.

```sql
SELECT DISTINCT location
FROM departments;
```

**Exercise 55:** Select employees with a salary greater than 50000.

```sql
SELECT * FROM employees
WHERE salary > 50000;
```

**Exercise 56:** Select the top 5 highest salaries from the `employees` table.

```sql
SELECT * FROM (
  SELECT * FROM employees
  ORDER BY salary DESC
)
WHERE ROWNUM <= 5;
```

### Using Joins

**Exercise 57:** Join `employees` and `departments` tables to show employee names and their department names.

```sql
SELECT e.first_name, d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id;
```

**Exercise 58:** Join `projects` and `employee_projects` to show project names and the number of hours worked on each project.

```sql
SELECT p.project_name, ep.hours_worked
FROM projects p
JOIN employee_projects ep ON p.project_id = ep.project_id;
```

**Exercise 59:** Join `employees` and `employee_projects` to show employees and the projects they are working on.

```sql
SELECT e.first_name, p.project_name
FROM employees e
JOIN employee_projects ep ON e.employee_id = ep.employee_id
JOIN projects p ON ep.project_id = p.project_id;
```

### Using Subqueries

**Exercise 60:** Find the names of employees who have a salary above the average salary.

```sql
SELECT first_name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
```

**Exercise 61:** Find the departments that have more than 5 employees.

```sql
SELECT department_id
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 5;
```

**Exercise 62:** List employees who are assigned to a project with a name starting with 'Project'.

```sql
SELECT e.first_name
FROM employees e
WHERE EXISTS (
  SELECT 1
  FROM employee_projects ep
  JOIN projects p ON ep.project_id = p.project_id
  WHERE ep.employee_id = e.employee_id
    AND p.project_name LIKE 'Project%'
);
```

**Exercise 63:** Find the maximum salary from employees who work in the 'IT' department.

```sql
SELECT MAX(salary)
FROM employees
WHERE department_id = (SELECT department_id FROM departments WHERE department_name = 'IT');
```

### Using Aggregate Functions

**Exercise 64:** Calculate the average salary of employees.

```sql
SELECT AVG(salary) AS average_salary
FROM employees;
```

**Exercise 65:** Find the minimum salary in the `employees` table.

```sql
SELECT MIN(salary) AS min_salary
FROM employees;
```

**Exercise 66:** Find the total number of employees.

```sql
SELECT COUNT(*) AS total_employees
FROM employees;
```

### Using Group By

**Exercise 67:** Find the average salary for each department.

```sql
SELECT department_id, AVG(salary) AS avg_salary
FROM employees
GROUP BY department_id;
```

**Exercise 68:** Count the number of projects in each department.

```sql
SELECT department_id, COUNT(*) AS num_projects
FROM projects
GROUP BY department_id;
```

### Using Order By

**Exercise 69:** Select employees ordered by `hire_date` and then by `salary`.

```sql
SELECT first_name, hire_date, salary
FROM employees
ORDER BY hire_date ASC, salary DESC;
```

**Exercise 70:** Select employees with salaries greater than 50000 and order them by `salary` in ascending order.

```sql
SELECT first_name, salary
FROM employees
WHERE salary > 50000
ORDER BY salary ASC;
```

### Using Union and Union All

**Exercise 71:** Union the names of employees and contractors, removing duplicates.

```sql
SELECT name FROM employees
UNION
SELECT name FROM contractors;
```

**Exercise 72:** Union all names from employees and contractors, including duplicates.

```sql
SELECT name FROM employees
UNION ALL
SELECT name FROM contractors;
```

---

## 3. Advanced SQL Exercises

### Using Analytical Functions

**Exercise 73:** Calculate the average salary for employees, including the average salary as a column.

```sql
SELECT first_name, salary,
       AVG(salary) OVER () AS avg_salary
FROM employees;
```

**Exercise 74:** Use the `NTILE()` function to divide employees into 4 salary groups.

```sql
SELECT first_name, salary,
       NTILE(4) OVER (ORDER BY salary DESC) AS salary_group
FROM employees;
```

### Using Common Table Expressions (CTEs)

**Exercise 75:** Use a recursive CTE to display an organizational hierarchy.

```sql
WITH RECURSIVE org_chart AS (
  SELECT employee_id, first_name, manager_id
  FROM employees
  WHERE manager_id IS NULL
  UNION ALL
  SELECT e.employee_id, e.first_name, e.manager_id
  FROM employees e
  INNER JOIN org_chart o ON e.manager_id = o.employee_id
)
SELECT * FROM org_chart;
```

**Exercise 76:** Use a CTE to find the top 3 highest salaries.

```sql
WITH salary_rank AS (
  SELECT first_name, salary,
         RANK() OVER (ORDER BY salary DESC) AS salary_rank
  FROM employees
)
SELECT first_name, salary
FROM salary_rank
WHERE salary_rank <= 3;
```

### Using Case Statements

**Exercise 77:** Categorize employees based on their hire date into 'New', 'Mid-term', and 'Long-term'.

```sql
SELECT first_name, hire_date,
       CASE
         WHEN hire_date > SYSDATE - INTERVAL '1' YEAR THEN 'New'
         WHEN hire_date > SYSDATE - INTERVAL '5' YEAR THEN 'Mid-term'
         ELSE 'Long-term'
       END AS employment_status
FROM employees;
```

### Using Window Functions

**Exercise 78:** Calculate the cumulative salary for each employee.

```sql
SELECT first_name

, salary,
       SUM(salary) OVER (ORDER BY hire_date) AS cumulative_salary
FROM employees;
```

**Exercise 79:** Calculate the moving average salary for each employee over the last 6 months.

```sql
SELECT first_name, salary,
       AVG(salary) OVER (ORDER BY hire_date RANGE BETWEEN INTERVAL '6' MONTH PRECEDING AND CURRENT ROW) AS moving_avg_salary
FROM employees;
```

### Using PIVOT and UNPIVOT

**Exercise 80:** Pivot employee salaries by department.

```sql
SELECT *
FROM (SELECT department_id, salary FROM employees)
PIVOT (
  SUM(salary) FOR department_id IN (1 AS HR, 2 AS IT, 3 AS Finance)
);
```

**Exercise 81:** Unpivot data to show employees and their respective salaries.

```sql
SELECT first_name, salary
FROM (
  SELECT first_name, HR, IT, Finance
  FROM (SELECT first_name, department_id, salary FROM employees)
  PIVOT (
    MAX(salary) FOR department_id IN (1 AS HR, 2 AS IT, 3 AS Finance)
  )
)
UNPIVOT (
  salary FOR department_name IN (HR, IT, Finance)
);
```

### Creating and Using Materialized Views

**Exercise 82:** Create a materialized view to store aggregated employee data.

```sql
CREATE MATERIALIZED VIEW mv_employee_summary
AS
SELECT department_id, AVG(salary) AS avg_salary, COUNT(*) AS total_employees
FROM employees
GROUP BY department_id;
```

**Exercise 83:** Refresh the materialized view created above.

```sql
EXEC DBMS_MVIEW.REFRESH('mv_employee_summary');
```

### Creating and Using Triggers

**Exercise 84:** Create a trigger to automatically update the `last_modified` date when an employee record is updated.

```sql
CREATE OR REPLACE TRIGGER trg_update_employee
BEFORE UPDATE ON employees
FOR EACH ROW
BEGIN
  :NEW.last_modified := SYSDATE;
END;
```

**Exercise 85:** Create a trigger to prevent deletion of records from `employees` table if `salary` is above 100000.

```sql
CREATE OR REPLACE TRIGGER trg_prevent_delete
BEFORE DELETE ON employees
FOR EACH ROW
BEGIN
  IF :OLD.salary > 100000 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Cannot delete employees with salary above 100000');
  END IF;
END;
```

### Creating and Using Stored Procedures

**Exercise 86:** Create a stored procedure to increase the salary of employees by a given percentage.

```sql
CREATE OR REPLACE PROCEDURE increase_salary (p_percentage IN NUMBER) IS
BEGIN
  UPDATE employees
  SET salary = salary * (1 + p_percentage / 100);
END;
```

**Exercise 87:** Call the stored procedure to increase salaries by 10%.

```sql
BEGIN
  increase_salary(10);
END;
```

### Creating and Using Functions

**Exercise 88:** Create a function to calculate the bonus of an employee based on salary.

```sql
CREATE OR REPLACE FUNCTION calculate_bonus (p_salary IN NUMBER) RETURN NUMBER IS
BEGIN
  RETURN p_salary * 0.1;
END;
```

**Exercise 89:** Use the function to get bonus for an employee with salary 50000.

```sql
SELECT calculate_bonus(50000) AS bonus
FROM dual;
```

### Using Dynamic SQL

**Exercise 90:** Create a dynamic SQL statement to select data from a table specified at runtime.

```sql
DECLARE
  v_table_name VARCHAR2(30) := 'employees';
  v_sql        VARCHAR2(1000);
BEGIN
  v_sql := 'SELECT * FROM ' || v_table_name;
  EXECUTE IMMEDIATE v_sql;
END;
```

**Exercise 91:** Create a dynamic SQL statement to insert data into a table specified at runtime.

```sql
DECLARE
  v_table_name VARCHAR2(30) := 'employees';
  v_sql        VARCHAR2(1000);
BEGIN
  v_sql := 'INSERT INTO ' || v_table_name || ' (employee_id, first_name, last_name, hire_date, salary) VALUES (1, ''Jane'', ''Smith'', TO_DATE(''2023-06-15'', ''YYYY-MM-DD''), 60000)';
  EXECUTE IMMEDIATE v_sql;
END;
```

---

## 4. Additional Exercises

### Nested Queries

**Exercise 92:** Find the `first_name` of employees who have the highest salary.

```sql
SELECT first_name
FROM employees
WHERE salary = (SELECT MAX(salary) FROM employees);
```

### Advanced Joins

**Exercise 93:** Use a self-join to find employees who have the same job title.

```sql
SELECT e1.first_name AS employee1, e2.first_name AS employee2
FROM employees e1
JOIN employees e2 ON e1.job_title = e2.job_title
WHERE e1.employee_id != e2.employee_id;
```

### Regular Expressions

**Exercise 94:** Find employees whose email address contains 'example.com'.

```sql
SELECT first_name, email
FROM employees
WHERE REGEXP_LIKE(email, 'example\.com$');
```

### Hierarchical Queries

**Exercise 95:** Use a hierarchical query to display an organizational structure.

```sql
SELECT employee_id, first_name, manager_id
FROM employees
START WITH manager_id IS NULL
CONNECT BY PRIOR employee_id = manager_id;
```

### SQL Performance Tuning

**Exercise 96:** Explain how to analyze and improve the performance of a query.

```sql
EXPLAIN PLAN FOR
SELECT * FROM employees WHERE salary > 50000;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**Exercise 97:** Use indexing to improve the performance of a query on the `employees` table.

```sql
CREATE INDEX idx_salary ON employees (salary);
```

**Exercise 98:** Use the SQL*Plus command `AUTOTRACE` to view the execution plan.

```sql
SET AUTOTRACE ON
SELECT * FROM employees WHERE salary > 50000;
```

**Exercise 99:** Use the `SQL Trace` utility to trace a query.

```sql
ALTER SESSION SET SQL_TRACE = TRUE;
SELECT * FROM employees WHERE salary > 50000;
ALTER SESSION SET SQL_TRACE = FALSE;
```

**Exercise 100:** Optimize a query by avoiding full table scans.

```sql
SELECT * FROM employees
WHERE employee_id = 1; -- Assuming there is an index on employee_id
```


## Solutions for Exercises

### 1. DDL Solutions

**Exercise 4:** Create a table named `employees`.

```sql
CREATE TABLE employees (
  employee_id NUMBER PRIMARY KEY,
  first_name VARCHAR2(50),
  last_name VARCHAR2(50),
  hire_date DATE,
  salary NUMBER
);
```

**Exercise 5:** Create a table named `departments`.

```sql
CREATE TABLE departments (
  department_id NUMBER PRIMARY KEY,
  department_name VARCHAR2(50),
  location VARCHAR2(50)
);
```

**Exercise 6:** Create a table named `projects`.

```sql
CREATE TABLE projects (
  project_id NUMBER PRIMARY KEY,
  project_name VARCHAR2(100),
  start_date DATE,
  end_date DATE
);
```

**Exercise 7:** Create a table named `employee_projects`.

```sql
CREATE TABLE employee_projects (
  employee_id NUMBER,
  project_id NUMBER,
  hours_worked NUMBER,
  PRIMARY KEY (employee_id, project_id),
  FOREIGN KEY (employee_id) REFERENCES employees(employee_id),
  FOREIGN KEY (project_id) REFERENCES projects(project_id)
);
```

### 2. DML Solutions

**Exercise 40:** Insert a record into the `employees` table.

```sql
INSERT INTO employees (employee_id, first_name, last_name, hire_date, salary)
VALUES (1, 'John', 'Doe', TO_DATE('2022-01-15', 'YYYY-MM-DD'), 50000);
```

**Exercise 41:** Insert multiple records into the `departments` table.

```sql
INSERT INTO departments (department_id, department_name, location)
VALUES (1, 'HR', 'New York'),
       (2, 'IT', 'San Francisco'),
       (3, 'Finance', 'Chicago');
```

**Exercise 42:** Insert data into the `projects` table.

```sql
INSERT INTO projects (project_id, project_name, start_date, end_date)
VALUES (1, 'Project Alpha', TO_DATE('2023-03-01', 'YYYY-MM-DD'), TO_DATE('2023-09-30', 'YYYY-MM-DD'));
```

**Exercise 43:** Insert data into the `employee_projects` table.

```sql
INSERT INTO employee_projects (employee_id, project_id, hours_worked)
VALUES (1, 1, 120);
```

**Exercise 48:** Delete an employee with `employee_id` 1.

```sql
DELETE FROM employees
WHERE employee_id = 1;
```

**Exercise 49:** Delete all records from the `departments` table.

```sql
DELETE FROM departments;
```

**Exercise 51:** Delete all records from the `employee_projects` table where `hours_worked` is less than 100.

```sql
DELETE FROM employee_projects
WHERE hours_worked < 100;
```

### 3. Advanced SQL Solutions

**Exercise 73:** Calculate the average salary for employees, including the average salary as a column.

```sql
SELECT first_name, salary,
       AVG(salary) OVER () AS avg_salary
FROM employees;
```

**Exercise 74:** Use the `NTILE()` function to divide employees into 4 salary groups.

```sql
SELECT first_name, salary,
       NTILE(4) OVER (ORDER BY salary DESC) AS salary_group
FROM employees;
```

**Exercise 75:** Use a recursive CTE to display an organizational hierarchy.

```sql
WITH RECURSIVE org_chart AS (
  SELECT employee_id, first_name, manager_id
  FROM employees
  WHERE manager_id IS NULL
  UNION ALL
  SELECT e.employee_id, e.first_name, e.manager_id
  FROM employees e
  INNER JOIN org_chart o ON e.manager_id = o.employee_id
)
SELECT * FROM org_chart;
```

**Exercise 76:** Use a CTE to find the top 3 highest salaries.

```sql
WITH salary_rank AS (
  SELECT first_name, salary,
         RANK() OVER (ORDER BY salary DESC) AS salary_rank
  FROM employees
)
SELECT first_name, salary
FROM salary_rank
WHERE salary_rank <= 3;
```

**Exercise 77:** Categorize employees based on their hire date into 'New', 'Mid-term', and 'Long-term'.

```sql
SELECT first_name, hire_date,
       CASE
         WHEN hire_date > SYSDATE - INTERVAL '1' YEAR THEN 'New'
         WHEN hire_date > SYSDATE - INTERVAL '5' YEAR THEN 'Mid-term'
         ELSE 'Long-term'
       END AS employment_status
FROM employees;
```

**Exercise 78:** Calculate the cumulative salary for each employee.

```sql
SELECT first_name, salary,
       SUM(salary) OVER (ORDER BY hire_date) AS cumulative_salary
FROM employees;
```

**Exercise 79:** Calculate the moving average salary for each employee over the last 6 months.

```sql
SELECT first_name, salary,
       AVG(salary) OVER (ORDER BY hire_date RANGE BETWEEN INTERVAL '6' MONTH PRECEDING AND CURRENT ROW) AS moving_avg_salary
FROM employees;
```

**Exercise 80:** Pivot employee salaries by department.

```sql
SELECT *
FROM (SELECT department_id, salary FROM employees)
PIVOT (
  SUM(salary) FOR department_id IN (1 AS HR, 2 AS IT, 3 AS Finance)
);
```

**Exercise 81:** Unpivot data to show employees and their respective salaries.

```sql
SELECT first_name, salary
FROM (
  SELECT first_name, HR, IT, Finance
  FROM (SELECT first_name, department_id, salary FROM employees)
  PIVOT (
    MAX(salary) FOR department_id IN (1 AS HR, 2 AS IT, 3 AS Finance)
  )
)
UNPIVOT (
  salary FOR department_name IN (HR, IT, Finance)
);
```

**Exercise 82:** Create a materialized view to store aggregated employee data.

```sql
CREATE MATERIALIZED VIEW mv_employee_summary
AS
SELECT department_id, AVG(salary) AS avg_salary, COUNT(*) AS total_employees
FROM employees
GROUP BY department_id;
```

**Exercise 83:** Refresh the materialized view created above.

```sql
EXEC DBMS_MVIEW.REFRESH('mv_employee_summary');
```

**Exercise 84:** Create a trigger to automatically update the `last_modified` date when an employee record is updated.

```sql
CREATE OR REPLACE TRIGGER trg_update_employee
BEFORE UPDATE ON employees
FOR EACH ROW
BEGIN
  :NEW.last_modified := SYSDATE;
END;
```

**Exercise 85:** Create a trigger to prevent deletion of records from `employees` table if `salary` is above 100000.

```sql
CREATE OR REPLACE TRIGGER trg_prevent_delete
BEFORE DELETE ON employees
FOR EACH ROW
BEGIN
  IF :OLD.salary > 100000 THEN
    RAISE_APPLICATION_ERROR(-20001, 'Cannot delete employees with salary above 100000');
  END IF;
END;
```

**Exercise 86:** Create a stored procedure to increase the salary of employees by a given percentage.

```sql
CREATE OR REPLACE PROCEDURE increase_salary (p_percentage IN NUMBER) IS
BEGIN
  UPDATE employees
  SET salary = salary * (1 + p_percentage / 100);
END;
```

**Exercise 87:** Call the stored procedure to increase salaries by 10%.

```sql
BEGIN
  increase_salary(10);
END;
```

**Exercise 88:** Create a function to calculate the bonus of an employee based on salary.

```sql
CREATE OR REPLACE FUNCTION calculate_bonus (p_salary IN NUMBER) RETURN NUMBER IS
BEGIN
  RETURN p_salary * 0.1;
END;
```

**Exercise 89:** Use the function to get bonus for an employee with salary 50000.

```sql
SELECT calculate_bonus(50000) AS bonus
FROM dual;
```

**Exercise 90:** Create a dynamic SQL statement to select data from a table specified at runtime.

```sql
DECLARE
  v_table_name VARCHAR2(30) := 'employees';
  v_sql        VARCHAR2(1000);
BEGIN
  v_sql := 'SELECT * FROM ' || v_table_name;
  EXECUTE IMMEDIATE v_sql;
END;
```

**Exercise 91:** Create a dynamic SQL statement to insert data into a table specified at runtime.

```sql
DECLARE
  v_table_name VARCHAR2(30) := 'employees';
  v_sql        VARCHAR2(1000);
BEGIN
  v_sql := 'INSERT INTO ' || v_table_name || ' (employee_id, first_name, last_name, hire_date, salary) VALUES (1, ''Jane'', ''Smith'', TO_DATE(''2023-06-15'', ''YYYY-MM-DD''), 60000)';
  EXECUTE IMMEDIATE v_sql;
END;
```

### 4. Additional Exercises Solutions

**Exercise 92:** Find the `first_name` of employees who have the highest salary.

```sql
SELECT first_name
FROM employees
WHERE salary = (SELECT MAX(salary) FROM employees);
```

**Exercise 93:** Use a self-join to find employees who have the same job title.

```sql
SELECT e1.first_name AS employee1, e2.first_name AS employee2
FROM employees e1
JOIN employees e2 ON e1.job_title = e2.job_title
WHERE e1.employee_id != e2.employee_id;
```

**Exercise 94:** Find employees whose email address contains 'example.com'.

```sql
SELECT first_name, email
FROM employees
WHERE REGEXP_L

IKE(email, 'example\.com$');
```

**Exercise 95:** Use a hierarchical query to display an organizational structure.

```sql
SELECT employee_id, first_name, manager_id
FROM employees
START WITH manager_id IS NULL
CONNECT BY PRIOR employee_id = manager_id;
```

**Exercise 96:** Explain how to analyze and improve the performance of a query.

```sql
EXPLAIN PLAN FOR
SELECT * FROM employees WHERE salary > 50000;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

**Exercise 97:** Use indexing to improve the performance of a query on the `employees` table.

```sql
CREATE INDEX idx_salary ON employees (salary);
```

**Exercise 98:** Use the SQL*Plus command `AUTOTRACE` to view the execution plan.

```sql
SET AUTOTRACE ON
SELECT * FROM employees WHERE salary > 50000;
```

**Exercise 99:** Use the `SQL Trace` utility to trace a query.

```sql
ALTER SESSION SET SQL_TRACE = TRUE;
SELECT * FROM employees WHERE salary > 50000;
ALTER SESSION SET SQL_TRACE = FALSE;
```

**Exercise 100:** Optimize a query by avoiding full table scans.

```sql
SELECT * FROM employees
WHERE employee_id = 1; -- Assuming there is an index on employee_id
```

