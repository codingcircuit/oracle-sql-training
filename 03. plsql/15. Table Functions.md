# 15. Table Functions
Table functions in PL/SQL provide a mechanism to return a set of rows from a function, which can then be queried like a regular table. This feature allows for advanced data manipulation and integration of procedural logic into SQL queries.

## Index

1. [Introduction](#introduction)
2. [Syntax](#syntax)
3. [Creating Table Functions](#creating-table-functions)
4. [Use Cases](#use-cases)
5. [Advantages](#advantages)
6. [Examples](#examples)
   1. [Basic Table Function](#example-1-basic-table-function)
   2. [Table Function with Parameters](#example-2-table-function-with-parameters)
   3. [Table Function with Sorting](#example-3-table-function-with-sorting)
   4. [Table Function with Aggregation](#example-4-table-function-with-aggregation)
   5. [Table Function with Conditional Logic](#example-5-table-function-with-conditional-logic)
   6. [Table Function with Complex Joins](#example-6-table-function-with-complex-joins)
   7. [Table Function with Date Filtering](#example-7-table-function-with-date-filtering)
   8. [Table Function with Multiple Parameters](#example-8-table-function-with-multiple-parameters)
   9. [Table Function Returning XML Data](#example-9-table-function-returning-xml-data)
   10. [Table Function for Data Transformation](#example-10-table-function-for-data-transformation)
7. [Conclusion](#conclusion)

## Introduction

A table function is a PL/SQL function that returns a collection of rows. These functions can be used in SQL queries as if they were tables, allowing for a combination of procedural and declarative programming.

## Syntax

```sql
CREATE OR REPLACE FUNCTION function_name (parameter_list)
RETURN TABLE_TYPE
AS
BEGIN
    -- Function logic
END;
/
```

### Components:
- **`function_name`**: Name of the function.
- **`parameter_list`**: Parameters required by the function.
- **`TABLE_TYPE`**: The type of table or collection that the function returns.

## Creating Table Functions

To use a table function, you first need to define the object and table types it will work with. Here is a typical setup:

### Define Object and Table Types

```sql
-- Define an object type
CREATE OR REPLACE TYPE employee_type AS OBJECT (
    emp_id NUMBER,
    emp_name VARCHAR2(50),
    emp_salary NUMBER
);
/

-- Define a table type of the object
CREATE OR REPLACE TYPE employee_table_type AS TABLE OF employee_type;
/
```

<br>  

<br>  


## Use Cases

1. **Complex Queries**: Incorporate procedural logic within queries.
2. **Data Transformation**: Process and transform data before returning it.
3. **Dynamic Data Retrieval**: Adapt query logic based on input parameters.
4. **Integration**: Seamlessly integrate procedural code with SQL queries.

<br>  

<br>  

## Advantages

1. **Enhanced Data Processing:**
   - **Flexibility:** Allows for the execution of complex data processing and transformations within the function, returning results as a table.
   - **Complex Logic:** Enables the incorporation of intricate business logic and data manipulation that is not easily achieved with standard SQL queries.

2. **Integration with SQL:**
   - **SQL Queries:** Table functions can be seamlessly integrated into SQL queries, allowing for sophisticated querying and data manipulation within a single SQL statement.
   - **Seamless Integration:** Provides a bridge between procedural PL/SQL code and declarative SQL queries, enhancing code modularity and reusability.

3. **Improved Performance:**
   - **Efficient Data Handling:** Can process and return large datasets efficiently, particularly when using pipelined functions that enable streaming data processing.
   - **Bulk Processing:** Supports bulk collection and processing, reducing context switching between PL/SQL and SQL engines.

4. **Modularity and Reusability:**
   - **Encapsulation:** Encapsulates complex data processing logic within a function, promoting modularity and code reuse.
   - **Reusable Components:** Can be reused across different SQL queries and PL/SQL blocks, reducing redundancy and maintenance efforts.

5. **Advanced Data Handling:**
   - **Complex Data Types:** Supports the use of complex data types and structures, enabling advanced data handling and manipulation.
   - **Dynamic SQL:** Allows for the use of dynamic SQL within the function to handle varying query requirements and conditions.

6. **Error Handling:**
   - **Robust Error Handling:** Provides mechanisms for handling exceptions and errors within the function, ensuring robust data processing.
   - **Graceful Failure:** Allows for graceful handling of errors and exceptions, minimizing the impact on the overall data processing flow.

7. **Pipelined Processing:**
   - **Streaming Data:** Pipelined table functions support streaming data, allowing for the processing of large datasets without the need for intermediate storage.
   - **Reduced Memory Usage:** Can reduce memory usage and improve performance by processing and returning rows incrementally.

8. **Flexibility in Querying:**
   - **Dynamic Queries:** Supports the creation of dynamic queries within the function, allowing for flexible and adaptable querying based on runtime conditions.
   - **Customizable Results:** Enables the customization of results based on function parameters, providing tailored data outputs.

9. **Data Integration:**
   - **Integration with External Data Sources:** Can integrate with external data sources or systems, providing a unified view of data within SQL queries.
   - **XML and JSON Data:** Supports the processing of XML and JSON data, enabling integration with modern data formats and systems.

10. **Support for Recursive Queries:**
    - **Recursive Data Processing:** Facilitates recursive data processing and querying, useful for hierarchical or tree-structured data.


<br>  

<br>  

## Examples

### Example 1: Basic Table Function

#### Define Object and Table Types

```sql
-- Already defined above
```

#### Create Table Function

```sql
-- Function to return all employees
CREATE OR REPLACE FUNCTION get_all_employees
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary FROM employees) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_all_employees);
```

### Example 2: Table Function with Parameters

#### Create Table Function with Parameter

```sql
-- Function to return employees by department
CREATE OR REPLACE FUNCTION get_employees_by_dept(dept_id NUMBER)
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary
                FROM employees
                WHERE department_id = dept_id) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_employees_by_dept(10));
```

### Example 3: Table Function with Sorting

#### Create Table Function with Sorting

```sql
-- Function to return employees sorted by salary
CREATE OR REPLACE FUNCTION get_employees_sorted_by_salary
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary
                FROM employees
                ORDER BY emp_salary DESC) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_employees_sorted_by_salary);
```

### Example 4: Table Function with Aggregation

#### Create Table Function with Aggregation

```sql
-- Function to return department-wise salary totals
CREATE OR REPLACE FUNCTION get_dept_salary_totals
RETURN SYS_REFCURSOR
AS
    result_cursor SYS_REFCURSOR;
BEGIN
    OPEN result_cursor FOR
    SELECT department_id, SUM(salary) AS total_salary
    FROM employees
    GROUP BY department_id;
    
    RETURN result_cursor;
END;
/
```

#### Query

```sql
-- Query using OPEN_CURSOR to fetch results
DECLARE
    cur SYS_REFCURSOR;
    dept_id NUMBER;
    total_salary NUMBER;
BEGIN
    cur := get_dept_salary_totals;
    LOOP
        FETCH cur INTO dept_id, total_salary;
        EXIT WHEN cur%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Dept ID: ' || dept_id || ' Total Salary: ' || total_salary);
    END LOOP;
    CLOSE cur;
END;
/
```

### Example 5: Table Function with Conditional Logic

#### Create Table Function with Conditional Logic

```sql
-- Function to return employees with a salary above a certain threshold
CREATE OR REPLACE FUNCTION get_high_salary_employees(min_salary NUMBER)
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary
                FROM employees
                WHERE emp_salary > min_salary) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_high_salary_employees(50000));
```

### Example 6: Table Function with Complex Joins

#### Create Table Function with Joins

```sql
-- Function to return employees along with their manager's name
CREATE OR REPLACE FUNCTION get_employees_with_managers
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT e.emp_id, e.emp_name, e.emp_salary, m.emp_name AS manager_name
                FROM employees e
                LEFT JOIN employees m ON e.manager_id = m.emp_id) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_employees_with_managers);
```

### Example 7: Table Function with Date Filtering

#### Create Table Function with Date Filtering

```sql
-- Function to return employees hired after a certain date
CREATE OR REPLACE FUNCTION get_employees_hired_after(hire_date DATE)
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary
                FROM employees
                WHERE hire_date > hire_date) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_employees_hired_after(TO_DATE('2023-01-01', 'YYYY-MM-DD')));
```

### Example 8: Table Function with Multiple Parameters

#### Create Table Function with Multiple Parameters

```sql
-- Function to return employees by department and salary range
CREATE OR REPLACE FUNCTION get_employees_by_dept_salary(dept_id NUMBER, min_salary NUMBER, max_salary NUMBER)
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary
                FROM employees
                WHERE department_id = dept_id
                AND emp_salary BETWEEN min_salary AND max_salary) LOOP
        employee

_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_employees_by_dept_salary(10, 30000, 70000));
```

### Example 9: Table Function Returning XML Data

#### Create Table Function Returning XML

```sql
-- Function to return employee details as XML
CREATE OR REPLACE FUNCTION get_employees_as_xml
RETURN CLOB
AS
    xml_output CLOB;
BEGIN
    SELECT XMLELEMENT("Employees",
           XMLAGG(
             XMLELEMENT("Employee",
               XMLFOREST(e.emp_id AS "ID", e.emp_name AS "Name", e.emp_salary AS "Salary")
             )
           )
         ).getCLOBVal()
    INTO xml_output
    FROM employees e;

    RETURN xml_output;
END;
/
```

#### Query

```sql
DECLARE
    xml_data CLOB;
BEGIN
    xml_data := get_employees_as_xml;
    DBMS_OUTPUT.PUT_LINE(xml_data);
END;
/
```

### Example 10: Table Function for Data Transformation

#### Create Table Function for Data Transformation

```sql
-- Function to return employees with salary increased by a percentage
CREATE OR REPLACE FUNCTION get_employees_with_salary_increase(percentage NUMBER)
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary
                FROM employees) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary * (1 + percentage / 100));
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_employees_with_salary_increase(10));
```

