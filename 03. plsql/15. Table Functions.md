# 15. Table Functions
Table functions in PL/SQL provide a mechanism to return a set of rows from a function, which can then be queried like a regular table. This feature allows for advanced data manipulation and integration of procedural logic into SQL queries.

## Index

1. [Introduction](#introduction)
2. [Syntax](#syntax)
3. [Creating Table Functions](#creating-table-functions)
4. [Use Cases](#use-cases)
5. [Advantages](#advantages)
6. [Examples](#examples)
   1. [Basic Table Function](#example-1-basic-table-function)
   2. [Table Function with Parameters](#example-2-table-function-with-parameters)
   3. [Table Function with Sorting](#example-3-table-function-with-sorting)
   4. [Table Function with Aggregation](#example-4-table-function-with-aggregation)
   5. [Table Function with Conditional Logic](#example-5-table-function-with-conditional-logic)
   6. [Table Function with Complex Joins](#example-6-table-function-with-complex-joins)
   7. [Table Function with Date Filtering](#example-7-table-function-with-date-filtering)
   8. [Table Function with Multiple Parameters](#example-8-table-function-with-multiple-parameters)
   9. [Table Function Returning XML Data](#example-9-table-function-returning-xml-data)
   10. [Table Function for Data Transformation](#example-10-table-function-for-data-transformation)
7. [Conclusion](#conclusion)

## Introduction

A table function is a PL/SQL function that returns a collection of rows. These functions can be used in SQL queries as if they were tables, allowing for a combination of procedural and declarative programming.

## Syntax

```sql
CREATE OR REPLACE FUNCTION function_name (parameter_list)
RETURN TABLE_TYPE
AS
BEGIN
    -- Function logic
END;
/
```

### Components:
- **`function_name`**: Name of the function.
- **`parameter_list`**: Parameters required by the function.
- **`TABLE_TYPE`**: The type of table or collection that the function returns.

## Creating Table Functions

To use a table function, you first need to define the object and table types it will work with. Here is a typical setup:

### Define Object and Table Types

```sql
-- Define an object type
CREATE OR REPLACE TYPE employee_type AS OBJECT (
    emp_id NUMBER,
    emp_name VARCHAR2(50),
    emp_salary NUMBER
);
/

-- Define a table type of the object
CREATE OR REPLACE TYPE employee_table_type AS TABLE OF employee_type;
/
```

## Use Cases

1. **Complex Queries**: Incorporate procedural logic within queries.
2. **Data Transformation**: Process and transform data before returning it.
3. **Dynamic Data Retrieval**: Adapt query logic based on input parameters.
4. **Integration**: Seamlessly integrate procedural code with SQL queries.

## Advantages

1. **Encapsulation**: Encapsulate complex query logic in a reusable function.
2. **Reusability**: Reuse functions across multiple queries.
3. **Flexibility**: Flexibly handle dynamic query requirements and complex logic.
4. **Performance**: Improve performance by optimizing data processing within the function.

## Examples

### Example 1: Basic Table Function

#### Define Object and Table Types

```sql
-- Already defined above
```

#### Create Table Function

```sql
-- Function to return all employees
CREATE OR REPLACE FUNCTION get_all_employees
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary FROM employees) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_all_employees);
```

### Example 2: Table Function with Parameters

#### Create Table Function with Parameter

```sql
-- Function to return employees by department
CREATE OR REPLACE FUNCTION get_employees_by_dept(dept_id NUMBER)
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary
                FROM employees
                WHERE department_id = dept_id) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_employees_by_dept(10));
```

### Example 3: Table Function with Sorting

#### Create Table Function with Sorting

```sql
-- Function to return employees sorted by salary
CREATE OR REPLACE FUNCTION get_employees_sorted_by_salary
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary
                FROM employees
                ORDER BY emp_salary DESC) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_employees_sorted_by_salary);
```

### Example 4: Table Function with Aggregation

#### Create Table Function with Aggregation

```sql
-- Function to return department-wise salary totals
CREATE OR REPLACE FUNCTION get_dept_salary_totals
RETURN SYS_REFCURSOR
AS
    result_cursor SYS_REFCURSOR;
BEGIN
    OPEN result_cursor FOR
    SELECT department_id, SUM(salary) AS total_salary
    FROM employees
    GROUP BY department_id;
    
    RETURN result_cursor;
END;
/
```

#### Query

```sql
-- Query using OPEN_CURSOR to fetch results
DECLARE
    cur SYS_REFCURSOR;
    dept_id NUMBER;
    total_salary NUMBER;
BEGIN
    cur := get_dept_salary_totals;
    LOOP
        FETCH cur INTO dept_id, total_salary;
        EXIT WHEN cur%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Dept ID: ' || dept_id || ' Total Salary: ' || total_salary);
    END LOOP;
    CLOSE cur;
END;
/
```

### Example 5: Table Function with Conditional Logic

#### Create Table Function with Conditional Logic

```sql
-- Function to return employees with a salary above a certain threshold
CREATE OR REPLACE FUNCTION get_high_salary_employees(min_salary NUMBER)
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary
                FROM employees
                WHERE emp_salary > min_salary) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_high_salary_employees(50000));
```

### Example 6: Table Function with Complex Joins

#### Create Table Function with Joins

```sql
-- Function to return employees along with their manager's name
CREATE OR REPLACE FUNCTION get_employees_with_managers
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT e.emp_id, e.emp_name, e.emp_salary, m.emp_name AS manager_name
                FROM employees e
                LEFT JOIN employees m ON e.manager_id = m.emp_id) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_employees_with_managers);
```

### Example 7: Table Function with Date Filtering

#### Create Table Function with Date Filtering

```sql
-- Function to return employees hired after a certain date
CREATE OR REPLACE FUNCTION get_employees_hired_after(hire_date DATE)
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary
                FROM employees
                WHERE hire_date > hire_date) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_employees_hired_after(TO_DATE('2023-01-01', 'YYYY-MM-DD')));
```

### Example 8: Table Function with Multiple Parameters

#### Create Table Function with Multiple Parameters

```sql
-- Function to return employees by department and salary range
CREATE OR REPLACE FUNCTION get_employees_by_dept_salary(dept_id NUMBER, min_salary NUMBER, max_salary NUMBER)
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary
                FROM employees
                WHERE department_id = dept_id
                AND emp_salary BETWEEN min_salary AND max_salary) LOOP
        employee

_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary);
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_employees_by_dept_salary(10, 30000, 70000));
```

### Example 9: Table Function Returning XML Data

#### Create Table Function Returning XML

```sql
-- Function to return employee details as XML
CREATE OR REPLACE FUNCTION get_employees_as_xml
RETURN CLOB
AS
    xml_output CLOB;
BEGIN
    SELECT XMLELEMENT("Employees",
           XMLAGG(
             XMLELEMENT("Employee",
               XMLFOREST(e.emp_id AS "ID", e.emp_name AS "Name", e.emp_salary AS "Salary")
             )
           )
         ).getCLOBVal()
    INTO xml_output
    FROM employees e;

    RETURN xml_output;
END;
/
```

#### Query

```sql
DECLARE
    xml_data CLOB;
BEGIN
    xml_data := get_employees_as_xml;
    DBMS_OUTPUT.PUT_LINE(xml_data);
END;
/
```

### Example 10: Table Function for Data Transformation

#### Create Table Function for Data Transformation

```sql
-- Function to return employees with salary increased by a percentage
CREATE OR REPLACE FUNCTION get_employees_with_salary_increase(percentage NUMBER)
RETURN employee_table_type
AS
    employee_list employee_table_type := employee_table_type();
BEGIN
    FOR rec IN (SELECT emp_id, emp_name, emp_salary
                FROM employees) LOOP
        employee_list.EXTEND;
        employee_list(employee_list.COUNT) := employee_type(rec.emp_id, rec.emp_name, rec.emp_salary * (1 + percentage / 100));
    END LOOP;

    RETURN employee_list;
END;
/
```

#### Query

```sql
SELECT * FROM TABLE(get_employees_with_salary_increase(10));
```

