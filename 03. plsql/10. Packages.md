# 10. Packages in PL/SQL

In PL/SQL, a package is a database object that groups logically related procedures, functions, variables, and cursors. Packages help in modularizing and organizing PL/SQL code, making it easier to manage and maintain. They also provide a way to encapsulate complex business logic and improve code reusability and security.

## Table of Contents

- [Overview](#overview)
- [Package Structure](#package-structure)
  - [Package Specification](#package-specification)
  - [Package Body](#package-body)
- [Creating Packages](#creating-packages)
  - [Package Specification Example](#package-specification-example)
  - [Package Body Example](#package-body-example)
- [Using Packages](#using-packages)
  - [Calling Package Procedures and Functions](#calling-package-procedures-and-functions)
- [Advantages of Packages](#advantages-of-packages)
- [Use Cases](#use-cases)
- [Examples](#examples)

## Overview

A PL/SQL package consists of two parts:

- **Package Specification**: Defines the public interface of the package. It declares the public procedures, functions, types, variables, and constants that can be accessed by other PL/SQL code.
- **Package Body**: Contains the implementation of the procedures and functions declared in the package specification. It also defines private procedures, functions, and variables that are not accessible outside the package.

## Package Structure

### Package Specification

The package specification is where you declare all public elements of the package. This includes the declarations of public procedures, functions, types, variables, and constants.

**Syntax**:

```sql
CREATE OR REPLACE PACKAGE package_name AS
    -- Public type declarations
    -- Public variable declarations
    -- Public constant declarations
    -- Public procedure declarations
    -- Public function declarations
END package_name;
```

### Package Body

The package body contains the actual implementation of the procedures and functions declared in the package specification. It also includes private elements that are only accessible within the package.

**Syntax**:

```sql
CREATE OR REPLACE PACKAGE BODY package_name AS
    -- Private type declarations
    -- Private variable declarations
    -- Private constant declarations

    -- Procedure implementations
    -- Function implementations
END package_name;
```

## Creating Packages

### Package Specification Example

This example shows a package specification with a procedure and a function.

```sql
CREATE OR REPLACE PACKAGE employee_pkg AS
    -- Public procedure declaration
    PROCEDURE update_salary(p_emp_id IN NUMBER, p_new_salary IN NUMBER);
    
    -- Public function declaration
    FUNCTION get_salary(p_emp_id IN NUMBER) RETURN NUMBER;
END employee_pkg;
```

### Package Body Example

This example shows the implementation of the package specification defined above.

```sql
CREATE OR REPLACE PACKAGE BODY employee_pkg AS

    PROCEDURE update_salary(p_emp_id IN NUMBER, p_new_salary IN NUMBER) IS
    BEGIN
        UPDATE employees
        SET salary = p_new_salary
        WHERE employee_id = p_emp_id;
        
        COMMIT;
    END update_salary;
    
    FUNCTION get_salary(p_emp_id IN NUMBER) RETURN NUMBER IS
        v_salary NUMBER;
    BEGIN
        SELECT salary INTO v_salary
        FROM employees
        WHERE employee_id = p_emp_id;
        
        RETURN v_salary;
    END get_salary;

END employee_pkg;
```

## Using Packages

### Calling Package Procedures and Functions

You can call the procedures and functions defined in a package using the following syntax:

**Calling a Procedure**:

```sql
BEGIN
    employee_pkg.update_salary(101, 25000);
END;
```

**Calling a Function**:

```sql
DECLARE
    v_salary NUMBER;
BEGIN
    v_salary := employee_pkg.get_salary(101);
    DBMS_OUTPUT.PUT_LINE('Salary: ' || v_salary);
END;
```

## Advantages of Packages

- **Modularity**: Packages allow you to group related procedures, functions, and other PL/SQL constructs into a single unit, improving code organization and readability.
- **Encapsulation**: You can hide the implementation details of procedures and functions, exposing only the public interface.
- **Reusability**: Commonly used logic can be encapsulated in packages and reused across different applications.
- **Improved Performance**: PL/SQL packages are loaded into memory once and can improve performance by reducing the number of calls to the database.
- **Easier Maintenance**: Changes to package implementation can be made without affecting the code that uses the package, provided the public interface remains unchanged.

## Use Cases

- **Business Logic Implementation**: Encapsulate complex business logic and database operations in a package for reuse across multiple applications or modules.
- **API Development**: Develop a package as an API to provide a consistent and controlled interface for other PL/SQL code and applications.
- **Code Organization**: Group related procedures and functions together to improve code organization and readability.

## Examples

### Example 1: Package for Employee Management

**Package Specification**:

```sql
CREATE OR REPLACE PACKAGE employee_mgmt AS
    PROCEDURE hire_employee(p_emp_id IN NUMBER, p_name IN VARCHAR2, p_salary IN NUMBER);
    FUNCTION get_employee_name(p_emp_id IN NUMBER) RETURN VARCHAR2;
END employee_mgmt;
```

**Package Body**:

```sql
CREATE OR REPLACE PACKAGE BODY employee_mgmt AS

    PROCEDURE hire_employee(p_emp_id IN NUMBER, p_name IN VARCHAR2, p_salary IN NUMBER) IS
    BEGIN
        INSERT INTO employees (employee_id, name, salary)
        VALUES (p_emp_id, p_name, p_salary);
        
        COMMIT;
    END hire_employee;
    
    FUNCTION get_employee_name(p_emp_id IN NUMBER) RETURN VARCHAR2 IS
        v_name VARCHAR2(100);
    BEGIN
        SELECT name INTO v_name
        FROM employees
        WHERE employee_id = p_emp_id;
        
        RETURN v_name;
    END get_employee_name;

END employee_mgmt;
```

### Example 2: Package for Reporting

**Package Specification**:

```sql
CREATE OR REPLACE PACKAGE report_pkg AS
    FUNCTION generate_report(p_report_id IN NUMBER) RETURN CLOB;
END report_pkg;
```

**Package Body**:

```sql
CREATE OR REPLACE PACKAGE BODY report_pkg AS

    FUNCTION generate_report(p_report_id IN NUMBER) RETURN CLOB IS
        v_report CLOB;
    BEGIN
        -- Generate report based on report_id
        v_report := 'Report data for ID: ' || p_report_id;
        
        RETURN v_report;
    END generate_report;

END report_pkg;
