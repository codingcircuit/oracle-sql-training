# 12. Collections

Collections in PL/SQL are data structures that allow you to store multiple values of the same type in a single variable. They are useful for handling sets of data in a flexible and efficient way. PL/SQL collections come in three types:

- **Associative Arrays (formerly known as Index-By Tables)**
- **Nested Tables**
- **VARRAYs (Variable-Size Arrays)**

This document provides a comprehensive overview of each collection type, including their use cases and examples.

## Table of Contents

- [Overview of Collections](#overview-of-collections)
- [Associative Arrays](#associative-arrays)
  - [Definition](#definition)
  - [Use Cases](#use-cases)
  - [Examples](#examples)
- [Nested Tables](#nested-tables)
  - [Definition](#definition-1)
  - [Use Cases](#use-cases-1)
  - [Examples](#examples-1)
- [VARRAYs (Variable-Size Arrays)](#varrays-variable-size-arrays)
  - [Definition](#definition-2)
  - [Use Cases](#use-cases-2)
  - [Examples](#examples-2)
- [Comparison of Collection Types](#comparison-of-collection-types)
- [Best Practices](#best-practices)

## Overview of Collections

Collections in PL/SQL are a powerful feature that allow you to group related data together. They can be used for a variety of tasks, such as:

- Storing intermediate results of queries
- Manipulating sets of data
- Passing multiple values between procedures

## Associative Arrays

### Definition

Associative Arrays (formerly known as Index-By Tables) are key-value pairs where each key is an index and each value is an element associated with that index. They are useful for situations where you need to access elements by unique keys.

### Use Cases

- Lookup tables where the index is a meaningful identifier.
- Temporary storage of data that needs to be indexed.

### Examples

#### 1. Basic Usage

```plsql
DECLARE
    TYPE emp_table IS TABLE OF employees%ROWTYPE INDEX BY PLS_INTEGER;
    emp_data emp_table;
BEGIN
    emp_data(1).employee_id := 100;
    emp_data(1).first_name := 'Steven';
    emp_data(1).last_name := 'King';
    
    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || emp_data(1).employee_id);
    DBMS_OUTPUT.PUT_LINE('First Name: ' || emp_data(1).first_name);
END;
```

#### 2. Using Strings as Keys

```plsql
DECLARE
    TYPE emp_names IS TABLE OF employees%ROWTYPE INDEX BY VARCHAR2(20);
    emp_data emp_names;
BEGIN
    emp_data('SKING').employee_id := 100;
    emp_data('SKING').first_name := 'Steven';
    
    DBMS_OUTPUT.PUT_LINE('Employee ID: ' || emp_data('SKING').employee_id);
    DBMS_OUTPUT.PUT_LINE('First Name: ' || emp_data('SKING').first_name);
END;
```

## Nested Tables

### Definition

Nested Tables are collections that can grow dynamically. Unlike arrays, nested tables can be stored in database columns and can contain an arbitrary number of elements.

### Use Cases

- Storing sets of data in a single row of a database table.
- Managing collections of objects where the number of elements is not known in advance.

### Examples

#### 1. Declaring and Using Nested Tables

```plsql
DECLARE
    TYPE number_table IS TABLE OF NUMBER;
    num_list number_table;
BEGIN
    num_list := number_table(1, 2, 3, 4, 5);
    
    FOR i IN 1 .. num_list.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Number: ' || num_list(i));
    END LOOP;
END;
```

#### 2. Nested Table as a Column

```plsql
-- Create a type and table to hold nested tables
CREATE OR REPLACE TYPE num_table_type AS TABLE OF NUMBER;

CREATE TABLE numbers_table (
    id NUMBER,
    numbers num_table_type
) NESTED TABLE numbers STORE AS numbers_table_nested;

-- PL/SQL code to insert and query data
DECLARE
    l_numbers num_table_type := num_table_type(10, 20, 30);
BEGIN
    INSERT INTO numbers_table (id, numbers)
    VALUES (1, l_numbers);
    
    FOR rec IN (SELECT * FROM numbers_table) LOOP
        DBMS_OUTPUT.PUT_LINE('ID: ' || rec.id);
        FOR i IN 1 .. rec.numbers.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE('Number: ' || rec.numbers(i));
        END LOOP;
    END LOOP;
END;
```

## VARRAYs (Variable-Size Arrays)

### Definition

VARRAYs (Variable-Size Arrays) are arrays with a fixed maximum size. They are useful when you need to store a fixed number of elements in a collection.

### Use Cases

- Storing a fixed-size set of values that do not need to grow beyond a specified limit.
- Efficient storage and retrieval of small sets of data.

### Examples

#### 1. Declaring and Using VARRAYs

```plsql
-- Create a VARRAY type
CREATE OR REPLACE TYPE varray_type AS VARRAY(5) OF NUMBER;

-- PL/SQL code to use VARRAY
DECLARE
    l_varray varray_type := varray_type(1, 2, 3);
BEGIN
    FOR i IN 1 .. l_varray.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Number: ' || l_varray(i));
    END LOOP;
END;
```

#### 2. VARRAY as a Column

```plsql
-- Create a table with a VARRAY column
CREATE TABLE varray_table (
    id NUMBER,
    numbers varray_type
);

-- PL/SQL code to insert and query data
DECLARE
    l_varray varray_type := varray_type(10, 20, 30, 40);
BEGIN
    INSERT INTO varray_table (id, numbers)
    VALUES (1, l_varray);
    
    FOR rec IN (SELECT * FROM varray_table) LOOP
        DBMS_OUTPUT.PUT_LINE('ID: ' || rec.id);
        FOR i IN 1 .. rec.numbers.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE('Number: ' || rec.numbers(i));
        END LOOP;
    END LOOP;
END;
```

## Comparison of Collection Types

| Feature                   | Associative Arrays      | Nested Tables            | VARRAYs                   |
|---------------------------|--------------------------|---------------------------|---------------------------|
| **Index Type**            | Integer or String        | Integer                    | Integer                   |
| **Dynamic Size**          | No                       | Yes                        | No                        |
| **Storage in DB**         | No                       | Yes                        | Yes                       |
| **Use Case**              | Lookup tables, indexing  | Complex data, variable-size | Fixed-size data, small sets |
| **Performance**           | Fast access by index     | Dynamic operations        | Fixed size, efficient     |

## Best Practices

- **Use Associative Arrays** when you need fast lookups with unique keys and you donâ€™t need to store the data in the database.
- **Use Nested Tables** when you need to store variable-sized collections in the database and require dynamic resizing.
- **Use VARRAYs** when you have a fixed number of elements and need to store them efficiently.

In summary, understanding and choosing the right type of collection for your needs can significantly impact the performance and maintainability of your PL/SQL applications.


<br>  

<br>  

Certainly! Below is a Markdown (`.md`) file that covers complete use cases for collections in PL/SQL. This file provides detailed explanations, examples, and scenarios where each type of collection (Associative Arrays, Nested Tables, and VARRAYs) is particularly useful.


<br>  

<br>  


## Complete Use Cases for Collections in PL/SQL

PL/SQL collections are versatile data structures that are used to handle sets of related data. They include Associative Arrays, Nested Tables, and VARRAYs (Variable-Size Arrays). This document explores various use cases for each type of collection, showcasing their practical applications in real-world scenarios.

## Table of Contents

- [Associative Arrays](#associative-arrays)
  - [Use Cases](#use-cases)
  - [Examples](#examples)
- [Nested Tables](#nested-tables)
  - [Use Cases](#use-cases-1)
  - [Examples](#examples-1)
- [VARRAYs (Variable-Size Arrays)](#varrays-variable-size-arrays)
  - [Use Cases](#use-cases-2)
  - [Examples](#examples-2)
- [Best Practices](#best-practices)

## Associative Arrays

### Use Cases

1. **Lookup Tables**
   - **Scenario**: You have a mapping of employee IDs to names that is not stored in a database table but needs to be accessed frequently in a PL/SQL block.
   - **Benefit**: Associative Arrays allow quick access using unique keys without needing to query the database repeatedly.

2. **Temporary Data Storage**
   - **Scenario**: You need to store and process intermediate results from complex calculations or multiple database queries within a single execution block.
   - **Benefit**: Associative Arrays provide a flexible, in-memory data structure that can be dynamically resized.

3. **Dynamic Data Handling**
   - **Scenario**: You need to handle data with non-sequential indexes or where the index is not a simple integer.
   - **Benefit**: Associative Arrays support indexing by strings, which allows for more complex data handling scenarios.

### Examples

#### 1. Lookup Table Example

```plsql
DECLARE
    TYPE emp_lookup IS TABLE OF VARCHAR2(100) INDEX BY PLS_INTEGER;
    emp_names emp_lookup;
BEGIN
    emp_names(100) := 'Steven King';
    emp_names(101) := 'Neena Yang';
    
    DBMS_OUTPUT.PUT_LINE('Employee 100: ' || emp_names(100));
    DBMS_OUTPUT.PUT_LINE('Employee 101: ' || emp_names(101));
END;
```

#### 2. Temporary Data Storage Example

```plsql
DECLARE
    TYPE temp_data IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    data temp_data;
BEGIN
    data(1) := 5;
    data(2) := 10;
    data(3) := 15;
    
    FOR i IN 1 .. data.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Data ' || i || ': ' || data(i));
    END LOOP;
END;
```

## Nested Tables

### Use Cases

1. **Storing Complex Data Structures**
   - **Scenario**: You need to store a list of transactions or other complex data related to a single record in a database.
   - **Benefit**: Nested Tables can be stored in database columns, allowing you to handle complex data directly in the database.

2. **Handling Variable-Sized Data**
   - **Scenario**: You need to store a varying number of elements for each record, such as a variable number of product items in an order.
   - **Benefit**: Nested Tables dynamically resize and can accommodate varying amounts of data.

3. **Efficient Data Processing**
   - **Scenario**: You need to process a set of related records and perform operations like aggregations or filtering.
   - **Benefit**: Nested Tables allow for efficient manipulation and querying of complex data structures.

### Examples

#### 1. Creating and Using Nested Tables

```plsql
-- Create a nested table type
CREATE OR REPLACE TYPE num_table_type AS TABLE OF NUMBER;

-- Create a table with a nested table column
CREATE TABLE orders (
    order_id NUMBER,
    items num_table_type
) NESTED TABLE items STORE AS items_table;

-- PL/SQL code to insert and query nested table data
DECLARE
    l_items num_table_type := num_table_type(101, 102, 103);
BEGIN
    INSERT INTO orders (order_id, items)
    VALUES (1, l_items);
    
    FOR rec IN (SELECT * FROM orders) LOOP
        DBMS_OUTPUT.PUT_LINE('Order ID: ' || rec.order_id);
        FOR i IN 1 .. rec.items.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE('Item ID: ' || rec.items(i));
        END LOOP;
    END LOOP;
END;
```

## VARRAYs (Variable-Size Arrays)

### Use Cases

1. **Fixed-Size Data Storage**
   - **Scenario**: You need to store a small, fixed number of elements where the maximum number of elements is known ahead of time.
   - **Benefit**: VARRAYs are ideal for fixed-size collections, providing efficient storage and access.

2. **Passing Arrays Between PL/SQL Blocks**
   - **Scenario**: You need to pass a fixed-size array of data between different PL/SQL procedures or functions.
   - **Benefit**: VARRAYs facilitate passing multiple values as a single parameter.

3. **Efficient Data Handling in Limited Contexts**
   - **Scenario**: You need to handle a small, predefined list of values within a specific context, such as options for a user selection.
   - **Benefit**: VARRAYs provide a straightforward way to manage a small, fixed set of data.

### Examples

#### 1. Declaring and Using VARRAYs

```plsql
-- Create a VARRAY type
CREATE OR REPLACE TYPE varray_type AS VARRAY(3) OF NUMBER;

-- PL/SQL code to use VARRAY
DECLARE
    l_varray varray_type := varray_type(1, 2, 3);
BEGIN
    FOR i IN 1 .. l_varray.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Value: ' || l_varray(i));
    END LOOP;
END;
```

#### 2. VARRAY as a Table Column

```plsql
-- Create a table with a VARRAY column
CREATE TABLE product_orders (
    order_id NUMBER,
    product_ids varray_type
);

-- PL/SQL code to insert and query VARRAY data
DECLARE
    l_varray varray_type := varray_type(201, 202, 203);
BEGIN
    INSERT INTO product_orders (order_id, product_ids)
    VALUES (1, l_varray);
    
    FOR rec IN (SELECT * FROM product_orders) LOOP
        DBMS_OUTPUT.PUT_LINE('Order ID: ' || rec.order_id);
        FOR i IN 1 .. rec.product_ids.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE('Product ID: ' || rec.product_ids(i));
        END LOOP;
    END LOOP;
END;
```

## Best Practices

- **Choose the Right Collection Type**: Select the collection type that best fits your data and performance requirements. Use Associative Arrays for quick lookups, Nested Tables for variable-sized data, and VARRAYs for fixed-size collections.
- **Manage Collection Size**: Be aware of the limitations of each collection type. VARRAYs have a fixed size, while Nested Tables can grow dynamically.
- **Optimize Performance**: For large datasets or frequent operations, consider performance implications and choose collections accordingly. Nested Tables and VARRAYs have different performance characteristics.
- **Use Indexes Wisely**: Associative Arrays allow for indexing by integers or strings, which can be leveraged for efficient data access.

In summary, PL/SQL collections provide powerful tools for managing and processing sets of related data. By understanding and applying the appropriate collection type for different scenarios, you can significantly enhance the functionality and performance of your PL/SQL applications.

