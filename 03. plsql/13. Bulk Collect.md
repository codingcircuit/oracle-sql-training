# 13. BULK COLLECT

`BULK COLLECT` is a powerful feature in PL/SQL used to retrieve multiple rows of data from a SQL query into a PL/SQL collection in one operation. This improves performance by reducing the number of context switches between the SQL and PL/SQL engines.

## Table of Contents

- [Overview](#overview)
- [Syntax](#syntax)
- [Use Cases](#use-cases)
- [Examples](#examples)
  - [1. Basic BULK COLLECT Example](#1-basic-bulk-collect-example)
  - [2. BULK COLLECT with LIMIT](#2-bulk-collect-with-limit)
  - [3. BULK COLLECT with Multiple Collections](#3-bulk-collect-with-multiple-collections)
  - [4. BULK COLLECT with %ROWTYPE](#4-bulk-collect-with-rowtype)
  - [5. Handling Large Result Sets](#5-handling-large-result-sets)
- [Best Practices](#best-practices)

## Overview

`BULK COLLECT` allows you to fetch multiple rows from a query into PL/SQL collections (such as associative arrays, nested tables, or VARRAYs) in a single operation. This can significantly enhance performance, especially for large result sets, by minimizing the number of context switches between SQL and PL/SQL.

### Syntax

```plsql
SELECT column_list
INTO collection
FROM table
[WHERE condition];
```

Or, with multiple collections:

```plsql
SELECT column1, column2
INTO collection1, collection2
FROM table
[WHERE condition];
```

You can also use `BULK COLLECT` with `LIMIT` to control the number of rows fetched in each iteration:

```plsql
SELECT column_list
BULK COLLECT INTO collection
FROM table
[WHERE condition]
LIMIT n;
```

## Use Cases

1. **Fetching Large Result Sets**
   - **Scenario**: You need to retrieve a large number of rows from a table for processing in PL/SQL.
   - **Benefit**: `BULK COLLECT` allows you to fetch all rows at once, reducing the number of context switches and improving performance.

2. **Handling Complex Queries**
   - **Scenario**: You need to execute a complex query involving joins or aggregations and process the results in PL/SQL.
   - **Benefit**: `BULK COLLECT` can handle complex queries and efficiently load the results into PL/SQL collections.

3. **Pagination of Results**
   - **Scenario**: You need to process and display results in smaller chunks or pages.
   - **Benefit**: Using `BULK COLLECT` with `LIMIT`, you can fetch and process results in manageable chunks.

4. **Multiple Collections Retrieval**
   - **Scenario**: You need to retrieve and store results from a query into multiple PL/SQL collections simultaneously.
   - **Benefit**: `BULK COLLECT` supports fetching data into multiple collections in one operation.

## Examples

### 1. Basic BULK COLLECT Example

```plsql
DECLARE
    TYPE emp_table IS TABLE OF employees%ROWTYPE;
    l_employees emp_table;
BEGIN
    SELECT * 
    BULK COLLECT INTO l_employees
    FROM employees;
    
    FOR i IN 1 .. l_employees.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || l_employees(i).employee_id);
    END LOOP;
END;
```

### 2. BULK COLLECT with LIMIT

```plsql
DECLARE
    TYPE emp_table IS TABLE OF employees%ROWTYPE;
    l_employees emp_table;
    l_limit NUMBER := 100;
BEGIN
    OPEN c_employees FOR
        SELECT * FROM employees;
    
    LOOP
        FETCH c_employees BULK COLLECT INTO l_employees LIMIT l_limit;
        EXIT WHEN l_employees.COUNT = 0;
        
        FOR i IN 1 .. l_employees.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE('Employee ID: ' || l_employees(i).employee_id);
        END LOOP;
    END LOOP;
    
    CLOSE c_employees;
END;
```

### 3. BULK COLLECT with Multiple Collections

```plsql
DECLARE
    TYPE emp_ids IS TABLE OF employees.employee_id%TYPE;
    TYPE emp_names IS TABLE OF employees.first_name%TYPE;
    
    l_emp_ids emp_ids;
    l_emp_names emp_names;
BEGIN
    SELECT employee_id, first_name
    BULK COLLECT INTO l_emp_ids, l_emp_names
    FROM employees;
    
    FOR i IN 1 .. l_emp_ids.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || l_emp_ids(i) || ', Name: ' || l_emp_names(i));
    END LOOP;
END;
```

### 4. BULK COLLECT with %ROWTYPE

```plsql
DECLARE
    TYPE emp_table IS TABLE OF employees%ROWTYPE;
    l_employees emp_table;
BEGIN
    SELECT * 
    BULK COLLECT INTO l_employees
    FROM employees;
    
    FOR i IN 1 .. l_employees.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || l_employees(i).employee_id || ', Name: ' || l_employees(i).first_name);
    END LOOP;
END;
```

### 5. Handling Large Result Sets

```plsql
DECLARE
    CURSOR c_employees IS
        SELECT * FROM employees;
        
    TYPE emp_table IS TABLE OF employees%ROWTYPE;
    l_employees emp_table;
    l_limit NUMBER := 100;
BEGIN
    OPEN c_employees;
    
    LOOP
        FETCH c_employees BULK COLLECT INTO l_employees LIMIT l_limit;
        EXIT WHEN l_employees.COUNT = 0;
        
        FOR i IN 1 .. l_employees.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE('Employee ID: ' || l_employees(i).employee_id || ', Name: ' || l_employees(i).first_name);
        END LOOP;
    END LOOP;
    
    CLOSE c_employees;
END;
```

## Best Practices

- **Use LIMIT Wisely**: When handling large datasets, use the `LIMIT` clause to control the number of rows fetched in each iteration to avoid memory issues.
- **Minimize Context Switches**: `BULK COLLECT` helps minimize context switches between SQL and PL/SQL, but itâ€™s essential to balance it with proper exception handling and resource management.
- **Index Collections**: For large collections, consider using indexing to improve performance during data retrieval and manipulation.
- **Handle Exceptions**: Always include exception handling to manage errors that may occur during bulk operations.

By leveraging `BULK COLLECT`, you can significantly enhance the performance of PL/SQL blocks that deal with large volumes of data. Understanding and applying best practices ensures efficient and effective use of this powerful feature.

