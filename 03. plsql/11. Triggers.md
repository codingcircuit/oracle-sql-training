# 11. Triggers

Triggers in PL/SQL are special types of stored procedures that automatically execute (or "trigger") in response to specific events on a particular table or view. They are useful for maintaining data integrity, automating system tasks, and enforcing business rules.

## Table of Contents

- [Introduction to Triggers](#introduction-to-triggers)
- [Types of Triggers](#types-of-triggers)
  - [BEFORE Triggers](#before-triggers)
  - [AFTER Triggers](#after-triggers)
  - [INSTEAD OF Triggers](#instead-of-triggers)
- [Trigger Timing and Events](#trigger-timing-and-events)
- [Trigger Syntax](#trigger-syntax)
- [Trigger Example](#trigger-example)
- [Use Cases](#use-cases)
- [Best Practices](#best-practices)

## Introduction to Triggers

Triggers are special types of stored procedures that automatically execute in response to certain events on a table or view. They are defined to perform actions before or after data manipulation operations such as INSERT, UPDATE, or DELETE.

## Types of Triggers

### BEFORE Triggers

**BEFORE** triggers execute before the specified DML operation (INSERT, UPDATE, DELETE) is performed. They are commonly used to validate data or perform preprocessing tasks.

**Syntax:**
```plsql
CREATE [OR REPLACE] TRIGGER trigger_name
BEFORE INSERT OR UPDATE OR DELETE ON table_name
[FOR EACH ROW]
BEGIN
    -- Trigger body
END;
```

**Example:**
```plsql
CREATE OR REPLACE TRIGGER before_insert_trigger
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    :NEW.hire_date := SYSDATE;
END;
```
In this example, the trigger sets the `hire_date` to the current date before inserting a new record into the `employees` table.

### AFTER Triggers

**AFTER** triggers execute after the specified DML operation is completed. They are useful for performing tasks that depend on the successful completion of the DML operation.

**Syntax:**
```plsql
CREATE [OR REPLACE] TRIGGER trigger_name
AFTER INSERT OR UPDATE OR DELETE ON table_name
[FOR EACH ROW]
BEGIN
    -- Trigger body
END;
```

**Example:**
```plsql
CREATE OR REPLACE TRIGGER after_update_trigger
AFTER UPDATE ON employees
FOR EACH ROW
BEGIN
    INSERT INTO audit_log (employee_id, old_salary, new_salary, change_date)
    VALUES (:OLD.employee_id, :OLD.salary, :NEW.salary, SYSDATE);
END;
```
In this example, the trigger logs changes in the `salary` field to an `audit_log` table after an update operation on the `employees` table.

### INSTEAD OF Triggers

**INSTEAD OF** triggers are used to perform a different action in place of the specified DML operation. They are commonly used with views to perform DML operations on underlying tables.

**Syntax:**
```plsql
CREATE [OR REPLACE] TRIGGER trigger_name
INSTEAD OF INSERT OR UPDATE OR DELETE ON view_name
BEGIN
    -- Trigger body
END;
```

**Example:**
```plsql
CREATE OR REPLACE TRIGGER instead_of_insert_trigger
INSTEAD OF INSERT ON employee_view
BEGIN
    INSERT INTO employees (employee_id, first_name, last_name, hire_date)
    VALUES (:NEW.employee_id, :NEW.first_name, :NEW.last_name, :NEW.hire_date);
END;
```
In this example, the trigger performs an INSERT into the `employees` table instead of inserting into the `employee_view`.

## Trigger Timing and Events

Triggers can be fired in response to various events:

- **INSERT**: Fired when a new row is inserted.
- **UPDATE**: Fired when an existing row is modified.
- **DELETE**: Fired when a row is deleted.

Triggers can also be defined to fire **BEFORE** or **AFTER** the event occurs, depending on whether you want to perform actions before or after the actual DML operation.

## Trigger Syntax

Here's a general syntax for creating a trigger:

```plsql
CREATE [OR REPLACE] TRIGGER trigger_name
{BEFORE | AFTER | INSTEAD OF} {INSERT | UPDATE | DELETE} ON table_name
[FOR EACH ROW]
BEGIN
    -- Trigger body
END;
```

### Components:
- **`trigger_name`**: The name of the trigger.
- **`BEFORE | AFTER | INSTEAD OF`**: Specifies when the trigger should fire.
- **`INSERT | UPDATE | DELETE`**: Specifies the DML operation that triggers the execution.
- **`FOR EACH ROW`**: Specifies that the trigger should execute once for each affected row (if omitted, the trigger executes once per statement).
- **Trigger Body**: Contains the PL/SQL code to be executed.

## Trigger Example

**Example: Preventing Insertion of Future Dates**

This trigger prevents the insertion of records with future dates into the `employees` table.

```plsql
CREATE OR REPLACE TRIGGER prevent_future_dates
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    IF :NEW.hire_date > SYSDATE THEN
        RAISE_APPLICATION_ERROR(-20001, 'Hire date cannot be in the future.');
    END IF;
END;
```

## Use Cases

1. **Data Validation**: Ensuring that data meets specific criteria before being inserted or updated.
2. **Automated Actions**: Performing automatic actions such as updating related tables or logging changes.
3. **Enforcing Business Rules**: Implementing rules and restrictions that cannot be enforced through constraints alone.
4. **Audit Logging**: Tracking changes to data for auditing purposes.
5. **Complex Data Manipulations**: Handling complex data transformations that cannot be easily performed in a single DML statement.

## Best Practices

1. **Minimize Trigger Complexity**: Keep trigger logic as simple and efficient as possible to avoid performance issues.
2. **Avoid Recursive Triggers**: Be cautious of triggers that may cause recursion, leading to unintended behavior or infinite loops.
3. **Test Thoroughly**: Test triggers in a controlled environment to ensure they behave as expected and do not cause unintended side effects.
4. **Use Triggers Judiciously**: Use triggers when necessary and avoid overusing them, as they can complicate debugging and maintenance.
5. **Document Triggers**: Document the purpose and behavior of each trigger to facilitate maintenance and future development.

