# 14. Dynamic SQL

Dynamic SQL is a powerful feature in PL/SQL that allows you to construct and execute SQL statements dynamically at runtime. This flexibility is particularly useful when the SQL statement structure is not known until runtime.

## Table of Contents

- [Overview](#overview)
- [Types of Dynamic SQL](#types-of-dynamic-sql)
  - [1. EXECUTE IMMEDIATE](#1-execute-immediate)
  - [2. DBMS_SQL Package](#2-dbms_sql-package)
- [Syntax and Usage](#syntax-and-usage)
  - [1. EXECUTE IMMEDIATE Syntax](#1-execute-immediate-syntax)
  - [2. DBMS_SQL Syntax](#2-dbms_sql-syntax)
- [Use Cases](#use-cases)
  - [1. Dynamic Table Names](#1-dynamic-table-names)
  - [2. Conditional SQL Execution](#2-conditional-sql-execution)
  - [3. Dynamic DDL Statements](#3-dynamic-ddl-statements)
  - [4. Dynamic Queries](#4-dynamic-queries)
- [Examples](#examples)
  - [1. Simple EXECUTE IMMEDIATE Example](#1-simple-execute-immediate-example)
  - [2. EXECUTE IMMEDIATE with Bind Variables](#2-execute-immediate-with-bind-variables)
  - [3. Using DBMS_SQL Package](#3-using-dbms_sql-package)
  - [4. Dynamic DDL Execution](#4-dynamic-ddl-execution)
  - [5. Dynamic SQL for Data Retrieval](#5-dynamic-sql-for-data-retrieval)
- [Best Practices](#best-practices)
- [References](#references)

## Overview

Dynamic SQL allows you to build and execute SQL statements dynamically at runtime, which provides flexibility for complex and variable queries. This capability is essential for scenarios where SQL statements cannot be predetermined and need to be constructed dynamically based on varying conditions.

## Types of Dynamic SQL

### 1. EXECUTE IMMEDIATE

`EXECUTE IMMEDIATE` is used for executing a single SQL statement dynamically. It can handle DML (Data Manipulation Language) and DDL (Data Definition Language) statements.

### 2. DBMS_SQL Package

The `DBMS_SQL` package provides more control over dynamic SQL execution and is used for executing multiple SQL statements and handling complex SQL operations.

## Syntax and Usage

### 1. EXECUTE IMMEDIATE Syntax

```sql
EXECUTE IMMEDIATE sql_string
[INTO {variable | record}]
[USING [IN] bind_variable[, ...]];
```

- `sql_string`: The SQL statement to be executed.
- `INTO`: Optionally specifies a PL/SQL variable or record to receive the result.
- `USING`: Binds variables to the SQL statement.

### 2. DBMS_SQL Syntax

```sql
DECLARE
    l_cursor INTEGER;
    l_sql VARCHAR2(1000);
BEGIN
    l_cursor := DBMS_SQL.OPEN_CURSOR;
    l_sql := 'SELECT * FROM employees WHERE department_id = :dept_id';
    
    DBMS_SQL.PARSE(l_cursor, l_sql, DBMS_SQL.STATIC);
    DBMS_SQL.BIND_VARIABLE(l_cursor, ':dept_id', 10);
    DBMS_SQL.EXECUTE(l_cursor);
    -- Fetch and process the results here
    DBMS_SQL.CLOSE_CURSOR(l_cursor);
END;
```

- `DBMS_SQL.OPEN_CURSOR`: Opens a new cursor.
- `DBMS_SQL.PARSE`: Parses the SQL statement.
- `DBMS_SQL.BIND_VARIABLE`: Binds variables to the SQL statement.
- `DBMS_SQL.EXECUTE`: Executes the SQL statement.
- `DBMS_SQL.CLOSE_CURSOR`: Closes the cursor.

## Use Cases

### 1. Dynamic Table Names

**Scenario**: Executing SQL statements on different tables based on user input.

**Benefit**: Allows flexibility in selecting which table to query or manipulate dynamically.

### 2. Conditional SQL Execution

**Scenario**: Executing different SQL statements based on runtime conditions.

**Benefit**: Provides the ability to adapt SQL execution paths based on varying conditions.

### 3. Dynamic DDL Statements

**Scenario**: Creating or modifying database objects such as tables, indexes, or views dynamically.

**Benefit**: Facilitates dynamic changes to the database schema.

### 4. Dynamic Queries

**Scenario**: Building and executing complex queries where column names, table names, or conditions are not known until runtime.

**Benefit**: Enables the execution of complex queries that are constructed dynamically based on user input or other runtime conditions.

## Examples

### 1. Simple EXECUTE IMMEDIATE Example

```sql
DECLARE
    v_table_name VARCHAR2(30) := 'employees';
BEGIN
    EXECUTE IMMEDIATE 'DELETE FROM ' || v_table_name;
    COMMIT;
END;
```

### 2. EXECUTE IMMEDIATE with Bind Variables

```sql
DECLARE
    v_department_id NUMBER := 10;
    v_employee_count NUMBER;
BEGIN
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM employees WHERE department_id = :dept_id'
    INTO v_employee_count
    USING v_department_id;
    
    DBMS_OUTPUT.PUT_LINE('Employee count: ' || v_employee_count);
END;
```

### 3. Using DBMS_SQL Package

```sql
DECLARE
    l_cursor INTEGER;
    l_sql VARCHAR2(1000) := 'SELECT * FROM employees WHERE department_id = :dept_id';
    l_dept_id NUMBER := 10;
    l_employee_count NUMBER;
BEGIN
    l_cursor := DBMS_SQL.OPEN_CURSOR;
    DBMS_SQL.PARSE(l_cursor, l_sql, DBMS_SQL.STATIC);
    DBMS_SQL.BIND_VARIABLE(l_cursor, ':dept_id', l_dept_id);
    DBMS_SQL.DEFINE_COLUMN(l_cursor, 1, l_employee_count);
    DBMS_SQL.EXECUTE(l_cursor);
    DBMS_SQL.FETCH_ROWS(l_cursor);
    DBMS_SQL.COLUMN_VALUE(l_cursor, 1, l_employee_count);
    DBMS_SQL.CLOSE_CURSOR(l_cursor);
    
    DBMS_OUTPUT.PUT_LINE('Employee count: ' || l_employee_count);
END;
```

### 4. Dynamic DDL Execution

```sql
DECLARE
    v_table_name VARCHAR2(30) := 'new_table';
BEGIN
    EXECUTE IMMEDIATE 'CREATE TABLE ' || v_table_name || ' (id NUMBER, name VARCHAR2(50))';
    DBMS_OUTPUT.PUT_LINE('Table ' || v_table_name || ' created.');
END;
```

### 5. Dynamic SQL for Data Retrieval

```sql
DECLARE
    v_sql VARCHAR2(1000);
    v_department_id NUMBER := 10;
    v_employee_name VARCHAR2(50);
BEGIN
    v_sql := 'SELECT first_name FROM employees WHERE department_id = :dept_id';
    
    EXECUTE IMMEDIATE v_sql
    INTO v_employee_name
    USING v_department_id;
    
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_employee_name);
END;
```

## Best Practices

- **Use Bind Variables**: Always use bind variables to avoid SQL injection and improve performance.
- **Handle Exceptions**: Include robust exception handling to manage errors in dynamic SQL execution.
- **Test Thoroughly**: Test dynamic SQL statements extensively to ensure they perform as expected and handle edge cases.
- **Avoid Overuse**: Use dynamic SQL judiciously as it can impact performance and readability. Prefer static SQL when possible.




Here is a Markdown (`.md`) file detailing the use cases of Dynamic SQL in PL/SQL:


<br>  

<br>  


# Use Cases for Dynamic SQL in PL/SQL

Dynamic SQL in PL/SQL allows for the execution of SQL statements that are constructed at runtime, offering great flexibility and power. This document explores various use cases for Dynamic SQL, providing insights into scenarios where dynamic SQL is advantageous.

## Table of Contents

- [Overview](#overview)
- [Use Cases](#use-cases)
  - [1. Executing SQL Statements with Variable Table Names](#1-executing-sql-statements-with-variable-table-names)
  - [2. Conditional SQL Execution](#2-conditional-sql-execution)
  - [3. Dynamic DDL Operations](#3-dynamic-ddl-operations)
  - [4. Handling Variable Column Names](#4-handling-variable-column-names)
  - [5. Building Dynamic Queries](#5-building-dynamic-queries)
  - [6. Data-Driven SQL Execution](#6-data-driven-sql-execution)
  - [7. Creating and Managing Database Objects](#7-creating-and-managing-database-objects)
- [Best Practices](#best-practices)
- [References](#references)

## Overview

Dynamic SQL enables PL/SQL to generate and execute SQL statements dynamically at runtime. This capability is essential when the structure of SQL statements cannot be determined until the program is executed. It allows for flexibility and adaptability in SQL execution.

## Use Cases

### 1. Executing SQL Statements with Variable Table Names

**Scenario**: A procedure needs to perform operations (e.g., INSERT, UPDATE, DELETE) on different tables based on user input or application logic.

**Benefit**: Allows the same code to operate on various tables without hardcoding table names.

**Example**:

```sql
DECLARE
    v_table_name VARCHAR2(30) := 'employees';
BEGIN
    EXECUTE IMMEDIATE 'DELETE FROM ' || v_table_name;
    COMMIT;
END;
```

### 2. Conditional SQL Execution

**Scenario**: Execute different SQL statements depending on runtime conditions, such as user roles or system states.

**Benefit**: Enables flexible and context-sensitive SQL execution.

**Example**:

```sql
DECLARE
    v_user_role VARCHAR2(20) := 'ADMIN';
BEGIN
    IF v_user_role = 'ADMIN' THEN
        EXECUTE IMMEDIATE 'SELECT * FROM admin_table';
    ELSE
        EXECUTE IMMEDIATE 'SELECT * FROM user_table';
    END IF;
END;
```

### 3. Dynamic DDL Operations

**Scenario**: Create, alter, or drop database objects like tables, indexes, or views dynamically based on application requirements.

**Benefit**: Supports dynamic schema changes and object management.

**Example**:

```sql
DECLARE
    v_table_name VARCHAR2(30) := 'new_table';
BEGIN
    EXECUTE IMMEDIATE 'CREATE TABLE ' || v_table_name || ' (id NUMBER, name VARCHAR2(50))';
    DBMS_OUTPUT.PUT_LINE('Table ' || v_table_name || ' created.');
END;
```

### 4. Handling Variable Column Names

**Scenario**: Build SQL queries where column names are not known until runtime, such as generating reports with variable fields.

**Benefit**: Facilitates dynamic query generation with different column requirements.

**Example**:

```sql
DECLARE
    v_column_name VARCHAR2(30) := 'salary';
    v_sql VARCHAR2(1000);
    v_total NUMBER;
BEGIN
    v_sql := 'SELECT SUM(' || v_column_name || ') FROM employees';
    
    EXECUTE IMMEDIATE v_sql INTO v_total;
    
    DBMS_OUTPUT.PUT_LINE('Total ' || v_column_name || ': ' || v_total);
END;
```

### 5. Building Dynamic Queries

**Scenario**: Construct complex queries dynamically based on user inputs or varying conditions, such as search criteria for a web application.

**Benefit**: Allows flexible query construction based on diverse and changing requirements.

**Example**:

```sql
DECLARE
    v_search_term VARCHAR2(50) := 'John';
    v_sql VARCHAR2(1000);
    v_result SYS_REFCURSOR;
    v_name VARCHAR2(50);
BEGIN
    v_sql := 'SELECT name FROM employees WHERE name LIKE :search_term';
    
    OPEN v_result FOR v_sql USING '%' || v_search_term || '%';
    
    LOOP
        FETCH v_result INTO v_name;
        EXIT WHEN v_result%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_name);
    END LOOP;
    
    CLOSE v_result;
END;
```

### 6. Data-Driven SQL Execution

**Scenario**: Execute SQL statements based on data-driven conditions, such as running different SQL based on user-selected parameters.

**Benefit**: Supports data-driven logic and operations.

**Example**:

```sql
DECLARE
    v_query VARCHAR2(1000);
    v_emp_count NUMBER;
BEGIN
    v_query := 'SELECT COUNT(*) FROM employees WHERE hire_date > :hire_date';
    
    EXECUTE IMMEDIATE v_query INTO v_emp_count USING TO_DATE('01-JAN-2020', 'DD-MON-YYYY');
    
    DBMS_OUTPUT.PUT_LINE('Number of employees hired after 01-JAN-2020: ' || v_emp_count);
END;
```

### 7. Creating and Managing Database Objects

**Scenario**: Dynamically create or modify database objects based on runtime conditions, such as creating a temporary table for a specific operation.

**Benefit**: Facilitates dynamic schema modifications and object management.

**Example**:

```sql
DECLARE
    v_object_name VARCHAR2(30) := 'temp_table_' || TO_CHAR(SYSDATE, 'YYYYMMDD');
BEGIN
    EXECUTE IMMEDIATE 'CREATE TABLE ' || v_object_name || ' (id NUMBER, description VARCHAR2(100))';
    DBMS_OUTPUT.PUT_LINE('Temporary table ' || v_object_name || ' created.');
    
    -- Later in the code, you might drop this table
    EXECUTE IMMEDIATE 'DROP TABLE ' || v_object_name;
    DBMS_OUTPUT.PUT_LINE('Temporary table ' || v_object_name || ' dropped.');
END;
```

