# 14 Dynamic SQL

Dynamic SQL is a powerful feature in PL/SQL that allows you to construct and execute SQL statements dynamically at runtime. This flexibility is particularly useful when the SQL statement structure is not known until runtime.

## Table of Contents

- [Overview](#overview)
- [Types of Dynamic SQL](#types-of-dynamic-sql)
  - [1. EXECUTE IMMEDIATE](#1-execute-immediate)
  - [2. DBMS_SQL Package](#2-dbms_sql-package)
- [Syntax and Usage](#syntax-and-usage)
  - [1. EXECUTE IMMEDIATE Syntax](#1-execute-immediate-syntax)
  - [2. DBMS_SQL Syntax](#2-dbms_sql-syntax)
- [Use Cases](#use-cases)
  - [1. Dynamic Table Names](#1-dynamic-table-names)
  - [2. Conditional SQL Execution](#2-conditional-sql-execution)
  - [3. Dynamic DDL Statements](#3-dynamic-ddl-statements)
  - [4. Dynamic Queries](#4-dynamic-queries)
- [Examples](#examples)
  - [1. Simple EXECUTE IMMEDIATE Example](#1-simple-execute-immediate-example)
  - [2. EXECUTE IMMEDIATE with Bind Variables](#2-execute-immediate-with-bind-variables)
  - [3. Using DBMS_SQL Package](#3-using-dbms_sql-package)
  - [4. Dynamic DDL Execution](#4-dynamic-ddl-execution)
  - [5. Dynamic SQL for Data Retrieval](#5-dynamic-sql-for-data-retrieval)
- [Best Practices](#best-practices)
- [References](#references)

## Overview

Dynamic SQL allows you to build and execute SQL statements dynamically at runtime, which provides flexibility for complex and variable queries. This capability is essential for scenarios where SQL statements cannot be predetermined and need to be constructed dynamically based on varying conditions.

## Types of Dynamic SQL

### 1. EXECUTE IMMEDIATE

`EXECUTE IMMEDIATE` is used for executing a single SQL statement dynamically. It can handle DML (Data Manipulation Language) and DDL (Data Definition Language) statements.

### 2. DBMS_SQL Package

The `DBMS_SQL` package provides more control over dynamic SQL execution and is used for executing multiple SQL statements and handling complex SQL operations.

## Syntax and Usage

### 1. EXECUTE IMMEDIATE Syntax

```sql
EXECUTE IMMEDIATE sql_string
[INTO {variable | record}]
[USING [IN] bind_variable[, ...]];
```

- `sql_string`: The SQL statement to be executed.
- `INTO`: Optionally specifies a PL/SQL variable or record to receive the result.
- `USING`: Binds variables to the SQL statement.

### 2. DBMS_SQL Syntax

```sql
DECLARE
    l_cursor INTEGER;
    l_sql VARCHAR2(1000);
BEGIN
    l_cursor := DBMS_SQL.OPEN_CURSOR;
    l_sql := 'SELECT * FROM employees WHERE department_id = :dept_id';
    
    DBMS_SQL.PARSE(l_cursor, l_sql, DBMS_SQL.STATIC);
    DBMS_SQL.BIND_VARIABLE(l_cursor, ':dept_id', 10);
    DBMS_SQL.EXECUTE(l_cursor);
    -- Fetch and process the results here
    DBMS_SQL.CLOSE_CURSOR(l_cursor);
END;
```

- `DBMS_SQL.OPEN_CURSOR`: Opens a new cursor.
- `DBMS_SQL.PARSE`: Parses the SQL statement.
- `DBMS_SQL.BIND_VARIABLE`: Binds variables to the SQL statement.
- `DBMS_SQL.EXECUTE`: Executes the SQL statement.
- `DBMS_SQL.CLOSE_CURSOR`: Closes the cursor.

## Use Cases

### 1. Dynamic Table Names

**Scenario**: Executing SQL statements on different tables based on user input.

**Benefit**: Allows flexibility in selecting which table to query or manipulate dynamically.

### 2. Conditional SQL Execution

**Scenario**: Executing different SQL statements based on runtime conditions.

**Benefit**: Provides the ability to adapt SQL execution paths based on varying conditions.

### 3. Dynamic DDL Statements

**Scenario**: Creating or modifying database objects such as tables, indexes, or views dynamically.

**Benefit**: Facilitates dynamic changes to the database schema.

### 4. Dynamic Queries

**Scenario**: Building and executing complex queries where column names, table names, or conditions are not known until runtime.

**Benefit**: Enables the execution of complex queries that are constructed dynamically based on user input or other runtime conditions.

## Examples

### 1. Simple EXECUTE IMMEDIATE Example

```sql
DECLARE
    v_table_name VARCHAR2(30) := 'employees';
BEGIN
    EXECUTE IMMEDIATE 'DELETE FROM ' || v_table_name;
    COMMIT;
END;
```

### 2. EXECUTE IMMEDIATE with Bind Variables

```sql
DECLARE
    v_department_id NUMBER := 10;
    v_employee_count NUMBER;
BEGIN
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM employees WHERE department_id = :dept_id'
    INTO v_employee_count
    USING v_department_id;
    
    DBMS_OUTPUT.PUT_LINE('Employee count: ' || v_employee_count);
END;
```

### 3. Using DBMS_SQL Package

```sql
DECLARE
    l_cursor INTEGER;
    l_sql VARCHAR2(1000) := 'SELECT * FROM employees WHERE department_id = :dept_id';
    l_dept_id NUMBER := 10;
    l_employee_count NUMBER;
BEGIN
    l_cursor := DBMS_SQL.OPEN_CURSOR;
    DBMS_SQL.PARSE(l_cursor, l_sql, DBMS_SQL.STATIC);
    DBMS_SQL.BIND_VARIABLE(l_cursor, ':dept_id', l_dept_id);
    DBMS_SQL.DEFINE_COLUMN(l_cursor, 1, l_employee_count);
    DBMS_SQL.EXECUTE(l_cursor);
    DBMS_SQL.FETCH_ROWS(l_cursor);
    DBMS_SQL.COLUMN_VALUE(l_cursor, 1, l_employee_count);
    DBMS_SQL.CLOSE_CURSOR(l_cursor);
    
    DBMS_OUTPUT.PUT_LINE('Employee count: ' || l_employee_count);
END;
```

### 4. Dynamic DDL Execution

```sql
DECLARE
    v_table_name VARCHAR2(30) := 'new_table';
BEGIN
    EXECUTE IMMEDIATE 'CREATE TABLE ' || v_table_name || ' (id NUMBER, name VARCHAR2(50))';
    DBMS_OUTPUT.PUT_LINE('Table ' || v_table_name || ' created.');
END;
```

### 5. Dynamic SQL for Data Retrieval

```sql
DECLARE
    v_sql VARCHAR2(1000);
    v_department_id NUMBER := 10;
    v_employee_name VARCHAR2(50);
BEGIN
    v_sql := 'SELECT first_name FROM employees WHERE department_id = :dept_id';
    
    EXECUTE IMMEDIATE v_sql
    INTO v_employee_name
    USING v_department_id;
    
    DBMS_OUTPUT.PUT_LINE('Employee Name: ' || v_employee_name);
END;
```

## Best Practices

- **Use Bind Variables**: Always use bind variables to avoid SQL injection and improve performance.
- **Handle Exceptions**: Include robust exception handling to manage errors in dynamic SQL execution.
- **Test Thoroughly**: Test dynamic SQL statements extensively to ensure they perform as expected and handle edge cases.
- **Avoid Overuse**: Use dynamic SQL judiciously as it can impact performance and readability. Prefer static SQL when possible.
