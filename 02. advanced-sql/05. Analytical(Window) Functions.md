# 5. Analytical (Window) Functions

Analytical (or window) functions in Oracle SQL perform calculations across a set of table rows that are somehow related to the current row. These functions are useful for tasks such as ranking, cumulative totals, moving averages, and more.

## Key Concepts

- **Window Function**: Performs calculations across a set of rows related to the current row within the result set.
- **Window**: A set of rows defined by the `OVER()` clause in which the function operates.
- **Partitioning**: Divides the result set into partitions to perform calculations within each partition.
- **Ordering**: Defines the sequence in which rows are processed within each partition.

## Common Analytical Functions

### 1. `ROW_NUMBER()`

The `ROW_NUMBER()` function assigns a unique sequential integer to rows within a partition of a result set.

#### Syntax
```sql
ROW_NUMBER() OVER (PARTITION BY partition_column ORDER BY order_column)
```

#### Example
```sql
SELECT employee_id, first_name, salary,
       ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) AS row_num
FROM employees;
```
This query assigns a unique row number to employees within each department, ordered by salary in descending order.

### 2. `RANK()`

The `RANK()` function assigns a unique rank to each row within a partition, with gaps in ranking for ties.

#### Syntax
```sql
RANK() OVER (PARTITION BY partition_column ORDER BY order_column)
```

#### Example
```sql
SELECT employee_id, first_name, salary,
       RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS rank
FROM employees;
```
This query ranks employees within each department based on salary, with gaps in ranking where multiple employees have the same salary.

### 3. `DENSE_RANK()`

The `DENSE_RANK()` function assigns ranks to rows within a partition, without gaps for ties.

#### Syntax
```sql
DENSE_RANK() OVER (PARTITION BY partition_column ORDER BY order_column)
```

#### Example
```sql
SELECT employee_id, first_name, salary,
       DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS dense_rank
FROM employees;
```
This query ranks employees within each department based on salary, with no gaps in ranking.

### 4. `NTILE()`

The `NTILE()` function divides the result set into a specified number of roughly equal parts and assigns a unique bucket number to each row.

#### Syntax
```sql
NTILE(number_of_buckets) OVER (PARTITION BY partition_column ORDER BY order_column)
```

#### Example
```sql
SELECT employee_id, first_name, salary,
       NTILE(4) OVER (PARTITION BY department_id ORDER BY salary DESC) AS quartile
FROM employees;
```
This query divides employees within each department into four quartiles based on salary.

### 5. `SUM()`, `AVG()`, `MIN()`, `MAX()`

Aggregate functions can also be used as window functions to perform calculations over a set of rows.

#### Syntax
```sql
SUM(column) OVER (PARTITION BY partition_column ORDER BY order_column [ROWS range])
```


### 6. `LEAD`

The `LEAD` function provides access to a row at a specified physical offset from that row within the result set.

### Syntax
```sql
LEAD(column_name, offset, default_value) OVER (PARTITION BY partition_column ORDER BY order_column)
```

- **column_name**: The column from which to retrieve the value.
- **offset**: The number of rows forward from the current row (default is 1).
- **default_value**: The value to return if the offset row is out of bounds (optional).

### Example
```sql
SELECT employee_id, salary,
       LEAD(salary, 1, 0) OVER (ORDER BY hire_date) AS next_salary
FROM employees;
```

In this query, the `LEAD` function retrieves the salary of the employee hired immediately after the current employee. If there is no next employee, it returns 0.

### 7. `LAG`

The `LAG` function provides access to a row at a specified physical offset before the current row within the result set.

### Syntax
```sql
LAG(column_name, offset, default_value) OVER (PARTITION BY partition_column ORDER BY order_column)
```

- **column_name**: The column from which to retrieve the value.
- **offset**: The number of rows backward from the current row (default is 1).
- **default_value**: The value to return if the offset row is out of bounds (optional).

### Example
```sql
SELECT employee_id, salary,
       LAG(salary, 1, 0) OVER (ORDER BY hire_date) AS previous_salary
FROM employees;
```

In this query, the `LAG` function retrieves the salary of the employee hired immediately before the current employee. If there is no previous employee, it returns 0.

## Use Cases

### 1. Calculating Differences

You can use `LEAD` and `LAG` to calculate differences between current and previous (or future) rows.

#### Example
```sql
SELECT employee_id, salary,
       salary - LAG(salary, 1) OVER (ORDER BY hire_date) AS salary_difference
FROM employees;
```
This query calculates the difference in salary between the current employee and the previous employee based on hire date.

### 2. Trend Analysis

These functions are useful for analyzing trends over time by comparing values between rows.

#### Example
```sql
SELECT hire_date, salary,
       LEAD(salary, 1) OVER (ORDER BY hire_date) AS next_salary,
       LAG(salary, 1) OVER (ORDER BY hire_date) AS previous_salary
FROM employees;
```
This query provides the current salary along with the next and previous salaries based on hire date, allowing for trend analysis.

### 3. Generating Reports

You can use `LEAD` and `LAG` to generate reports that require comparison between consecutive rows.

#### Example
```sql
SELECT employee_id, salary,
       LEAD(salary, 1, 'N/A') OVER (PARTITION BY department_id ORDER BY hire_date) AS next_salary
FROM employees;
```
In this example, the `LEAD` function is used to generate a report showing the current salary and the salary of the next employee within the same department.


#### Example
```sql
SELECT employee_id, first_name, salary,
       SUM(salary) OVER (PARTITION BY department_id ORDER BY hire_date RANGE BETWEEN INTERVAL '1' YEAR PRECEDING AND CURRENT ROW) AS running_total
FROM employees;
```
This query calculates a running total of salaries within each department over a 1-year range.


## Common Window Clauses

### 1. `PARTITION BY`

Divides the result set into partitions to perform calculations within each partition.

#### Example
```sql
SELECT employee_id, department_id, salary,
       RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS rank
FROM employees;
```

### 2. `ORDER BY`

Specifies the order in which rows are processed within each partition.

#### Example
```sql
SELECT employee_id, department_id, salary,
       ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY hire_date) AS row_num
FROM employees;
```

### 3. `ROWS`/`RANGE`

Defines the window frame to limit the rows used in calculations.

#### Example
```sql
SELECT employee_id, salary,
       SUM(salary) OVER (ORDER BY hire_date ROWS BETWEEN 5 PRECEDING AND CURRENT ROW) AS moving_sum
FROM employees;
```

